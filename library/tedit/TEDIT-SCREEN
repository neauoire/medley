(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "13-Sep-2022 12:40:14" 
{DSK}<Users>kaplan>Local>medley3.5>working-medley>library>tedit>TEDIT-SCREEN.;69 200721 

      :CHANGES-TO (VARS TEDIT-SCREENCOMS)

      :PREVIOUS-DATE "11-Sep-2022 16:30:45" 
{DSK}<Users>kaplan>Local>medley3.5>working-medley>library>tedit>TEDIT-SCREEN.;65)


(PRETTYCOMPRINT TEDIT-SCREENCOMS)

(RPAQQ TEDIT-SCREENCOMS
       ((DECLARE%: EVAL@COMPILE DONTCOPY (EXPORT (RECORDS THISLINE LINEDESCRIPTOR LINECACHE)
                                                (CONSTANTS (LMInvisibleRun 401)
                                                       (LMLooksChange 400)
                                                       (LineArraySize 512))
                                                (GLOBALVARS TEDIT.DONT.BREAK.CHARS 
                                                       TEDIT.DONT.LAST.CHARS)))
        (INITRECORDS THISLINE LINEDESCRIPTOR LINECACHE)
        (FNS \FORMATLINE \FORMATLINE.NEWNSCHARS \TEDIT.NSCHAR.RUN \TEDIT.PURGE.SPACES \DOFORMATTING)
        (FNS \DISPLAYLINE \TEDIT.LINECACHE \TEDIT.CREATE.LINECACHE \TEDIT.BLTCHAR)
        (DECLARE%: EVAL@COMPILE DONTCOPY 

               (* ;; "Machine independent version of \TEDIT.BLTCHAR")

               (MACROS MI-TEDIT.BLTCHAR))
        (FNS TEDIT.CR.UPDATESCREEN TEDIT.DELETELINE TEDIT.INSERT.DISPLAYTEXT 
             TEDIT.INSERT.UPDATESCREEN TEDIT.UPDATE.SCREEN \BACKFORMAT \FILLWINDOW \FIXDLINES 
             \FIXILINES \SHOWTEXT \TEDIT.ADJUST.LINES \TEDIT.CLEAR.SCREEN.BELOW.LINE 
             \TEDIT.CLOSEUPLINES \TEDIT.COPY.LINEDESCRIPTOR \TEDIT.FIXCHANGEDLINE 
             \TEDIT.FIXCHANGEDPART \TEDIT.INSERTLINE \TEDIT.LINE.LIST \TEDIT.MARK.LINES.DIRTY 
             \TEDIT.NEXT.LINE.BOTTOM)))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE THISLINE (
                    (* ;; 
        "Cache for line-related character location info, for selection and line-display code to use.")

                    (DESC FULLXPOINTER)                      (* ; 
                                                    "Line descriptor for the line this describes now")
                    LEN                                      (* ; "Length of the line in characters")
                    CHARS

                    (* ;; "Array of character codes (or objects) on the line (charcode of 400 => dummy entry for looks change--go get next entry in LOOKS)")

                    WIDTHS                                   (* ; 
                                                          "Array of each character's width in points")
                    LOOKS                                    (* ; 
     "Array of any looks changes within the line.  LOOKS (0) = starting character looks for the line")
                    TLSPACEFACTOR                            (* ; 
                                                   "The SPACEFACTOR to be used in printing this line")
                    TLFIRSTSPACE                             (* ; "The first space to which SPACEFACTOR is to apply.  This is used so that spaces to the left of a TAB have their default width.")
                    )
                   LEN _ 0 CHARS _ (ARRAY LineArraySize 'POINTER 0 0)
                   WIDTHS _ (ARRAY LineArraySize 'POINTER 0 0)
                   LOOKS _ (ARRAY LineArraySize 'POINTER NIL 0)
                   TLFIRSTSPACE _ 0)

(DATATYPE LINEDESCRIPTOR 
          (
           (* ;; 
       "Description of a single line of formatted text, either on the display or for a printed page.")

           YBOT                                              (* ; 
                                             "Y value for the bottom of the line (below the descent)")
           YBASE                                             (* ; 
                                                     "Yvalue for the base line the characters sit on")
           LEFTMARGIN                                        (* ; "Left margin, in screen points")
           RIGHTMARGIN                                       (* ; "Right margin, in screen points")
           LXLIM                                             (* ; "X value of right edge of rightmost character on the line (may exceed right margin, if char is a space.)")
           SPACELEFT                                         (* ; 
                                            "Space left on the line, ignoring trailing blanks & CRs.")
           LHEIGHT                                           (* ; 
                                                          "Total height of hte line, Ascent+Descent.")
           ASCENT                                            (* ; "Ascent of the line above YBASE")
           DESCENT                                           (* ; "How far line descends below YBASE")
           LTRUEDESCENT                                      (* ; 
                                       "The TRUE DESCENT for this line, unadjusted for line leading.")
           LTRUEASCENT                                       (* ; 
                               "The TRUE ASCENT for this line, unadjusted for pre-paragraph leading.")
           CHAR1                                             (* ; 
                                                            "CH# of the first character on the line.")
           CHARLIM                                           (* ; 
                                                             "CH# of the last character on the line")
           CHARTOP                                           (* ; 
                              "CH# of the character which forced the line break (may exceed CHARLIM)")
           NEXTLINE                                          (* ; "Next line chain pointer")
           (PREVLINE FULLXPOINTER)                           (* ; "Previous line chain pointer")
           LMARK                                             (* ; "One of SOLID, GREY, NIL.  Tells what kind of special-line marker should be put in the left margin for this paragraph.  (For hardcopy, can also be an indicator for special processing?)")
           LTEXTOBJ                                          (* ; "A cached TEXTOBJ that this line took its text from.  Used in hardcopy to disambiguate when chno's should be updated...")
           CACHE                                             (* ; "A cached THISLINE, for keeping hardcopy info around while we crunch with the line descriptors to make things fit.")
           LDOBJ                                             (* ; 
                                 "The object which lies behind this line of text, for updating, etc.")
           LFMTSPEC                                          (* ; 
                                             "The format spec for this line's paragraph (eventually)")
           (DIRTY FLAG)                                      (* ; 
                                            "T if this line has changed since it was last formatted.")
           (CR\END FLAG)                                     (* ; "T if this line ends with a CR.")
           (DELETED FLAG)                                    (* ; "T if this line has been completely deleted since it was last formatted or displayed.  (Used by deletion routines to detect garbage lines)")
           (LHASPROT FLAG)                                   (* ; 
                                                             "This line contains protected text.")
           (LHASTABS FLAG)                                   (* ; "If this line has a tab in it, this is the line-relative ch# of the final tab.  This is to let us punt properly with tabs in a line.")
           (1STLN FLAG)                                      (* ; 
                                                         "This line is the first line in a paragraph")
           (LSTLN FLAG)                                      (* ; 
                                                             "This is the last line in a paragraph")
           )
          CHARLIM _ 1000000 NEXTLINE _ NIL PREVLINE _ NIL DIRTY _ NIL YBOT _ 0 YBASE _ 0 LEFTMARGIN _
          0 DELETED _ NIL)

(DATATYPE LINECACHE (
                     (* ;; "Image cache for display lines.")

                     LCBITMAP                                (* ; 
                                         "The bitmap that will be used by this instance of the cache")
                     (LCNEXTCACHE FULLXPOINTER)              (* ; 
                                                   "The next cache in the chain, for screen updates.")
                     ))
)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER)
         (THISLINE 10 POINTER)
         (THISLINE 12 POINTER))
       '14)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)
(DECLARE%: EVAL@COMPILE 

(RPAQQ LMInvisibleRun 401)

(RPAQQ LMLooksChange 400)

(RPAQQ LineArraySize 512)


(CONSTANTS (LMInvisibleRun 401)
       (LMLooksChange 400)
       (LineArraySize 512))
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
)

(* "END EXPORTED DEFINITIONS")

)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER)
         (THISLINE 10 POINTER)
         (THISLINE 12 POINTER))
       '14)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)
(DEFINEQ

(\FORMATLINE
  [LAMBDA (TEXTOBJ FMTSPEC CH#1 OLINE 1STLN)                 (* ; "Edited 11-Sep-2022 16:30 by rmk")
                                                             (* ; "Edited  7-Sep-2022 18:12 by rmk")
                                                             (* ; "Edited  4-Sep-2022 18:37 by rmk")

    (* ;; "Given a starting place, format the next line of text.  Return the LINEDESCRIPTOR;  reusing OLINE if it's given.")

    (* ;; "If CH#1 is past end of document, \FORMATLINE returns an empty line descriptor that is set up right wrt leading and font.  This is used by \FILLWINDOW to create the dummy line at end of document when you hit an EOL there. The SPECVARS may be reset under the BIN, by the LOOKSUPDATEFN.")

    (BTVALIDATE '\FORMATLINE 'START TEXTOBJ)
    (SETQ CH#1 (IMAX CH#1 1))
    (PROG ([LINE (OR OLINE (create LINEDESCRIPTOR
                                  RIGHTMARGIN _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                  YBOT _ (SUB1 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ]
           (GATHERBLANK T)
           (TLEN 0)
           (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
           (THISLINE (ffetch (TEXTOBJ THISLINE) of TEXTOBJ))
           (LOOKNO 0)
           (INVISIBLERUNS 0)
           (ASCENT 0)
           (DESCENT 0)
           (PREVSP 0)
           (%#BLANKS 0)
           (DEFAULTTAB 36)
           (DS (WINDOWPROP (CAR (fetch (TEXTOBJ \WINDOW) of TEXTOBJ))
                      'DSP))
           CH#B CHNO LEFTEDGE TX DX TXB FORCEEND T1SPACE TXB1 DXB WIDTH LOOK#B FONT FONTWIDTHS TERMSA
           CLOOKS TSTREAM CHLIST WLIST LOOKS ASCENTB DESCENTB INVISIBLERUNSB TABPENDING BOX PC DEVICE
           SCALE NEWASCENT NEWDESCENT TABSPEC HARDCOPYMODE ORIGFMTSPEC PREVHYPH PREVDHYPH ORIGCHLIST
           ORIGWLIST *TEDIT-CACHED-FMTSPEC* START-OF-PIECE)
          (DECLARE (SPECVARS LOOKS CHLIST WLIST FONTWIDTHS CHNO ASCENT DESCENT LOOKNO LINE FONT 
                          INVISIBLERUNS DEVICE SCALE NEWASCENT NEWDESCENT TLEN START-OF-PIECE))

     (* ;; "Variables (TLEN = Current character count on the line")

     (* ;; "CHNO = Current character # in the text")

     (* ;; "DX = width of current char/object")

     (* ;; "TX = current right margin")

     (* ;; "TXB1 = right margin of the first space/tab/CR in a row of space/tab/CR")

     (* ;; "CH#B = The CHNO of most recent space/tab")

     (* ;; "TXB = right margin of most recent space/tab")

     (* ;; "DXB = width of most recent space/tab")

     (* ;; "PREVSP = location on the line of the previous space/tab to this space/tab + 1")

     (* ;; "T1SPACE = a space/CR/TAB has been seen")

     (* ;; "#BLANKS = # of spaces/tabs seen) ")

     (* ;; " LOOKNO = Current index into the LOOKS array.  Updated by \TEDIT.LOOKS.UPDATE as characters are read in)")

     (* ;; "LOOK#B = The LOOKNO of the most recent space/tab)")

     (* ;; "ASCENTB = Ascent at most recent potential line break point)")

     (* ;; "DESCENTB = Descent at most recent potential line break point)")

     (* ;; "Maybe *TEDIT-CACHED-FMTSPEC* is supposed to be free, held over between calls?  If so, INITVARS in TEDIT-SCREEN")

          (SETQ CHLIST (fetch (ARRAYP BASE) of (fetch (THISLINE CHARS) of THISLINE)))
          (SETQ ORIGCHLIST CHLIST)
          (SETQ WLIST (fetch (ARRAYP BASE) of (fetch (THISLINE WIDTHS) of THISLINE)))
          (SETQ ORIGWLIST WLIST)
          (SETQ LOOKS (fetch (THISLINE LOOKS) of THISLINE))  (* ; "The array")
          (SETQ TSTREAM (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
          (SETQ TERMSA (fetch (TEXTOBJ TXTTERMSA) of TEXTOBJ))
          (replace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with (FUNCTION \TEDIT.LOOKS.UPDATE))
          (freplace (LINEDESCRIPTOR CHARLIM) of LINE with TEXTLEN)
                                                             (* ; 
                                                      "Force each new line to find its true CHARLIM.")
          (freplace (LINEDESCRIPTOR DIRTY) of LINE with NIL) (* ; 
                                                        "And as unchanged since the last formatting.")
          (freplace (LINEDESCRIPTOR CR\END) of LINE with NIL)(* ; "Assume we won't see a CR.")
          (freplace (LINEDESCRIPTOR LHASTABS) of LINE with NIL)
                                                             (* ; "And has no TABs.")
          (SETQ PC (\CHTOPC CH#1 TEXTOBJ T))
          (CL:WHEN (AND PC (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PC))
                        (SETQ PC (\NEXT.VISIBLE.PIECE PC)))
              (SETQ CH#1 (\PCTOCH PC))                       (* ; 
                                                     "Unusual, simpler than keeping track on the fly")
              (SETQ START-OF-PIECE CH#1))
          (SETQ CH#B CH#1)                                   (* ; "Ready to go")
          (SETQ CHNO CH#1)
          (freplace (LINEDESCRIPTOR CHAR1) of LINE with CH#1)
          (COND
             (PC                                             (* ; "We have a visible piece!")
              (SETQ CLOOKS (PLOOKS PC))
              (\EDITSETA LOOKS 0 CLOOKS)
              (replace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with CLOOKS)
                                                             (* ; 
                                                        "So the LOOKSUPDATEFN initially does nothing")
              (\INSTALL.PIECE TSTREAM PC (- CH#1 START-OF-PIECE))
                                                             (* ; "Starting place, set up for BOUT")
                                                             (* ; "Save looks in the line cache")
              (replace (LINEDESCRIPTOR LHASPROT) of LINE with (fetch CLPROTECTED of CLOOKS))
                                                             (* ; 
                                          "Remember if the first character on the line is protected.")
              (CL:UNLESS FMTSPEC                             (* ; "Get the paragraph looks")
                  (SETQ FMTSPEC (OR (fetch (PIECE PPARALOOKS) of PC)
                                    (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ))))
              (SETQ FMTSPEC (\TEDIT.APPLY.PARASTYLES FMTSPEC PC TEXTOBJ))
              (SETQ ORIGFMTSPEC FMTSPEC)
              (CL:UNLESS (EQ ORIGFMTSPEC *TEDIT-CACHED-FMTSPEC*)

                  (* ;; "The cache of character styles for the current paragraph is invalid; flush it, and note the new paragraph to cache for.")

                  (SETQ *TEDIT-CURRENTPARA-CACHE* NIL)
                  (SETQ *TEDIT-CACHED-FMTSPEC* ORIGFMTSPEC))
              (COND
                 [(SETQ HARDCOPYMODE (fetch FMTHARDCOPY of FMTSPEC))
                                                             (* ; 
                                                "This line is a hardcopy line.  Scale things for it.")
                  [SETQ DEVICE (OR (fetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ)
                                   (replace (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ
                                      with (OPENIMAGESTREAM '{NODIRCORE} 'POSTSCRIPT]
                  (SETQ SCALE (DSPSCALE NIL DEVICE))
                  (SETQ FMTSPEC (\TEDIT.HCPYFMTSPEC FMTSPEC DEVICE))
                  (SETQ DEFAULTTAB (FIXR (FTIMES 36 SCALE)))
                  (SETQ LEFTEDGE (FIXR (FTIMES 8 SCALE]
                 (T                                          (* ; 
                                                       "Regular line.  Format at display resolutions")
                    (SETQ DEVICE (fetch (TEXTOBJ DISPLAYCACHEDS) of TEXTOBJ))
                    (SETQ SCALE 1)
                    (SETQ LEFTEDGE 8)))
              (SETQ TABSPEC (fetch TABSPEC of FMTSPEC))
              (CL:WHEN (type? FONTCLASS (SETQ FONT (fetch CLFONT of CLOOKS)))
                  (SETQ FONT (FONTCOPY (fetch CLFONT of CLOOKS)
                                    'DEVICE
                                    'DISPLAY)))              (* ; 
                                                             "Grab the initial font for this line")
              (SETQ NEWASCENT (IPLUS (fetch \SFAscent of FONT)
                                     (OR (fetch CLOFFSET of CLOOKS)
                                         0)))
              (SETQ ASCENTB NEWASCENT)
              (SETQ NEWDESCENT (IDIFFERENCE (fetch \SFDescent of FONT)
                                      (OR (fetch CLOFFSET of CLOOKS)
                                          0)))               (* ; 
                                                           "The initial ascent, per the initial font")
              (SETQ DESCENTB NEWDESCENT)                     (* ; 
                                                             "Initial descent, per the initial font.")
              (CL:WHEN HARDCOPYMODE                          (* ; 
                                 "If this is a hardcopy line, fetch the hardcopy version of the font")
                  (SETQ FONT (FONTCOPY (fetch CLFONT of CLOOKS)
                                    'DEVICE DEVICE)))

              (* ;; "This line starts a pargraph if it starts the document or it is at the beginning of a piece just after a last-paragraph piece. \INSTALL.PIECE sets it up.   What if the paragraph ending is invisible??")

              [SETQ 1STLN (OR (IEQP CH#1 1)
                              (AND (IEQP CH#1 START-OF-PIECE)
                                   (fetch (PIECE PPARALAST) of (PREVPIECE (fetch (TEXTSTREAM PIECE)
                                                                             of TSTREAM]
              (replace (LINEDESCRIPTOR 1STLN) of LINE with 1STLN)
              (replace (LINEDESCRIPTOR LMARK) of LINE with NIL)
                                                             (* ; "Assume no margin marker.")
              (CL:WHEN 1STLN

                  (* ;; 
                  "First line of a paragraph.  Special paragraph types get marked in the margin.")

                  (CL:WHEN [OR (EQ (fetch FMTPARATYPE of FMTSPEC)
                                   'PAGEHEADING)
                               (fetch FMTNEWPAGEBEFORE of FMTSPEC)
                               (fetch FMTNEWPAGEAFTER of FMTSPEC)
                               [AND (fetch FMTSPECIALX of FMTSPEC)
                                    (NOT (ZEROP (fetch FMTSPECIALX of FMTSPEC]
                               (AND (fetch FMTSPECIALY of FMTSPEC)
                                    (NOT (ZEROP (fetch FMTSPECIALY of FMTSPEC]
                      (replace (LINEDESCRIPTOR LMARK) of LINE with 'GREY)))
              [SETQ TX (IPLUS [FIXR (FTIMES SCALE (IPLUS 8 (fetch (TEXTOBJ WLEFT) of TEXTOBJ]
                              (CL:IF 1STLN
                                  (fetch 1STLEFTMAR of FMTSPEC)
                                  (fetch LEFTMAR of FMTSPEC))]
              (replace (LINEDESCRIPTOR LEFTMARGIN) of LINE with TX)
                                                             (* ; "Set the left margin accordingly")
              [SETQ WIDTH (COND
                             [(ZEROP (fetch RIGHTMAR of FMTSPEC))
                                                             (* ; 
                                                         "RIGHTMAR = 0 => follow the window's width.")
                              (FIXR (FTIMES SCALE (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                                         8]
                             (T (IPLUS LEFTEDGE (fetch RIGHTMAR of FMTSPEC]
              (replace (LINEDESCRIPTOR RIGHTMARGIN) of LINE with WIDTH)
              (SETQ TXB1 WIDTH)

              (* ;; "BIN does the fast case within a thin, character-set 0 piece, otherwise bails out to \TEXTBIN.  LOOKSUPDATEFN is called at piece boundaries, and returns \TEXTBIN if the stream runs out of characters.")

              (* ;; "TLEN is the only bounds-checking")

              (bind CH for old TLEN from TLEN to (- (FOLDLO LineArraySize 2)
                                                    2) as old CHNO from CHNO
                 while (ILEQ CHNO TEXTLEN) while (SETQ CH (BIN TSTREAM))
                 do 
                    (* ;; "The WHILE is there because we may reset TEXTLEN within the loop, and TO TEXTLEN only evaluates it once.  The LOOKSUPDATEFN may return NIL from (\TEXTBIN inside) BIN.")

                    [SETQ DX (COND
                                [(SMALLP CH)                 (* ; "CH is really a character")
                                 (COND
                                    ((AND (IGEQ CH 192)
                                          (ILEQ CH 207))     (* ; 
                                                       "This is an NS accent character.  Space it 0.")
                                     0)
                                    (T                       (* ; 
                                                             "Regular character.  Get it's width.")
                                       (\FGETCHARWIDTH FONT CH]
                                (T                           (* ; "CH is an object")
                                   (SETQ BOX (APPLY* (IMAGEOBJPROP CH 'IMAGEBOXFN)
                                                    CH DS TX WIDTH))
                                                             (* ; "Get its size")
                                   (SETQ NEWASCENT (IDIFFERENCE (fetch YSIZE of BOX)
                                                          (fetch YDESC of BOX)))
                                   (SETQ NEWDESCENT (fetch YDESC of BOX))
                                   (IMAGEOBJPROP CH 'BOUNDBOX BOX)
                                   (COND
                                      [HARDCOPYMODE (FIXR (FTIMES SCALE (fetch XSIZE of BOX]
                                      (T (fetch XSIZE of BOX] 
                                                             (* ; "Get CH's X width.")
                    [SELCHARQ CH
                         (SPACE                              (* ; 
                                  "CH is a <Space>.  Remember it, in case we need to break the line.")
                                (CL:WHEN GATHERBLANK
                                    (SETQ TXB1 TX)
                                    (SETQ GATHERBLANK NIL))
                                (SETQ CH#B CHNO)             (* ; 
    "put the location # of the previous space/tab in the character array instead of the space itself")
                                (\RPLPTR CHLIST 0 PREVSP)
                                (\RPLPTR WLIST 0 DX)
                                (SETQ PREVSP (ADD1 TLEN))
                                (SETQ T1SPACE T)
                                (SETQ PREVDHYPH NIL)
                                (SETQ PREVHYPH NIL)          (* ; 
              "We're now past needing any hyphens for line breaking, so forget the last hyphen spot.")
                                (add TX DX)
                                (SETQ TXB TX)
                                (SETQ DXB DX)
                                (SETQ LOOK#B LOOKNO)
                                (CL:WHEN NEWASCENT           (* ; "The ascent has changed;  catch it")
                                    (SETQ ASCENT (IMAX ASCENT NEWASCENT))
                                    (SETQ DESCENT (IMAX DESCENT NEWDESCENT))
                                    (SETQ NEWASCENT NIL))
                                (SETQ ASCENTB ASCENT)
                                (SETQ DESCENTB DESCENT)
                                (SETQ INVISIBLERUNSB INVISIBLERUNS)
                                (add %#BLANKS 1))
                         ((EOL CR LF)                        (* ; 
                                                       "Ch is a <Return>.  Force an end to the line.")
                              (freplace (LINEDESCRIPTOR CHARLIM) of LINE with CHNO)
                              (CL:WHEN (AND NEWASCENT (ZEROP ASCENT)
                                            (ZEROP DESCENT)) (* ; "The ascent has changed;  catch it")
                                  (SETQ ASCENT NEWASCENT)
                                  (SETQ DESCENT NEWDESCENT))
                              (SETQ FORCEEND T)
                              (SETQ PREVDHYPH NIL)
                              (SETQ PREVHYPH NIL)            (* ; 
              "We're now past needing any hyphens for line breaking, so forget the last hyphen spot.")
                              (\RPLPTR CHLIST 0 (CHARCODE EOL))
                              (\RPLPTR WLIST 0 (SETQ DX (IMAX DX 6)))
                              (CL:WHEN GATHERBLANK
                                  (SETQ TXB1 TX)
                                  (SETQ GATHERBLANK NIL))
                              (SETQ T1SPACE T)
                              (freplace (LINEDESCRIPTOR CR\END) of LINE with T)
                              (add TX DX)
                              (replace (LINEDESCRIPTOR LSTLN) of LINE with T)
                                                             (* ; 
                                      "This has to be done better when we get non-para breaking CRs.")
                              (RETURN))
                         (TAB 
                              (* ;; "Try to be reasonable with tabs.  This will create trouble when doing fast-case insert/delete, but Pah! for now.")

                              (replace (LINEDESCRIPTOR LHASTABS) of LINE with T)
                                                             (* ; "To disable smart screen update")
                              (CL:WHEN NEWASCENT             (* ; "The ascent has changed;  catch it")
                                  (SETQ ASCENT (IMAX ASCENT NEWASCENT))
                                  (SETQ DESCENT (IMAX DESCENT NEWDESCENT))
                                  (SETQ NEWASCENT NIL))
                              (\RPLPTR CHLIST 0 CH)
                              (SETQ TABPENDING
                               (\TEDIT.FORMATTABS TEXTOBJ TABSPEC THISLINE CHLIST WLIST TX DEFAULTTAB
                                      LEFTEDGE TABPENDING 0 NIL))
                                                             (* ; 
                             "Figure out which tab stop to use, and what we need to do to get there.")
                              [COND
                                 ((FIXP TABPENDING)          (* ; 
                            "If it returns a number, that is the new TX, adjusted for any prior tabs")
                                  (SETQ TX TABPENDING)
                                  (SETQ TABPENDING NIL))
                                 (TABPENDING                 (* ; 
                                                   "Otherwise, look in the PENDINGTAB for the new TX")
                                        (SETQ TX (fetch PTNEWTX of TABPENDING]
                              (CL:WHEN GATHERBLANK
                                  (SETQ TXB1 TX)
                                  (SETQ GATHERBLANK NIL))
                              (SETQ CH#B CHNO)
                              (SETQ DX (\GETBASEPTR WLIST 0))
                              (\TEDIT.PURGE.SPACES (fetch (THISLINE CHARS) of THISLINE)
                                     PREVSP)                 (* ; 
                         "All the spaces before a tab don't take part in justification from here on.")
                              (SETQ %#BLANKS 0)              (* ; 
                      "Also reset the count of spaces on this line, so we widen later spaces enough.")
                              (SETQ PREVSP 0)
                              (SETQ T1SPACE T)
                              (add TX DX)
                              (SETQ TXB TX)                  (* ; 
                              "Remember the world in case this is the 'space' before the line breaks")
                              (SETQ DXB DX)
                              (SETQ LOOK#B LOOKNO)
                              (SETQ ASCENTB ASCENT)
                              (SETQ DESCENTB DESCENT)
                              (SETQ PREVDHYPH NIL)
                              (SETQ PREVHYPH NIL)            (* ; 
              "We're now past needing any hyphens for line breaking, so forget the last hyphen spot.")
                              (SETQ INVISIBLERUNSB INVISIBLERUNS))
                         (PROGN (COND
                                   ((AND (EQ CH (CHARCODE "0,377"))
                                         (NOT (ffetch (TEXTOBJ TXTNONSCHARS) of TEXTOBJ)))

                                    (* ;; 
                           "Character-set change character.  This suggests undetected NS characters.")

                                    (\TEDIT.NSCHAR.RUN CHNO TEXTOBJ TSTREAM)
                                                             (* ; 
                                                    "Leaves us ready to BIN again at the same place.")

                                    (* ;; "Back up the cache pointers and counters so that when we go to the top of the loop we're where we are now.")

                                    (SETQ CHLIST (\ADDBASE CHLIST -2))
                                    (SETQ WLIST (\ADDBASE WLIST -2))
                                    (add CHNO -1)
                                    (add TLEN -1)

                                    (* ;; 
                               "Because moving to NS characters changes the TEXTLEN for the shorter.")

                                    (SETQ TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
                                   (T 
                                      (* ;; "Not a formatting character")

                                      (SETQ GATHERBLANK T)   (* ; "Blanks are interesting again.")
                                      (ADD TX DX)
                                      (COND
                                         ((IGREATERP TX WIDTH)
                                                             (* ; 
                                   "We're past the right margin;  stop formatting at the last blank.")
                                          (SETQ FORCEEND T)
                                          [COND
                                             (PREVDHYPH      (* ; 
                               "There's a hyphen we can break at.  Go back there and break the line.")
                                                    (freplace (LINEDESCRIPTOR CHARLIM) of LINE
                                                       with CH#B)
                                                    (\RPLPTR ORIGCHLIST (LLSH (SUB1 PREVDHYPH)
                                                                              1)
                                                           (CHARCODE "-"))
                                                    (\RPLPTR ORIGWLIST (LLSH (SUB1 PREVDHYPH)
                                                                             1)
                                                           (\FGETCHARWIDTH FONT (CHARCODE "-")))
                                                    (SETQ TX TXB)
                                                    (SETQ DX DXB)
                                                    (SETQ ASCENT ASCENTB)
                                                    (SETQ DESCENT DESCENTB)
                                                    (SETQ LOOKNO LOOK#B)
                                                    (SETQ INVISIBLERUNS INVISIBLERUNSB))
                                             ((OR PREVHYPH T1SPACE)
                                                             (* ; 
                                                        "Break the line at a previous breaking point")
                                              (freplace (LINEDESCRIPTOR CHARLIM) of LINE with CH#B)
                                              (SETQ TX TXB)
                                              (SETQ DX DXB)
                                              (SETQ ASCENT ASCENTB)
                                              (SETQ DESCENT DESCENTB)
                                              (SETQ LOOKNO LOOK#B)
                                              (SETQ INVISIBLERUNS INVISIBLERUNSB))
                                             ((IGREATERP TLEN 0)
                                              (freplace (LINEDESCRIPTOR CHARLIM) of LINE
                                                 with (IMAX (SUB1 CHNO)
                                                            CH#1))
                                              (SETQ TX (IDIFFERENCE TX DX))
                                                             (* ; 
                                           "No spaces on this line;  break it before this character.")

                                              (* ;; "Check line break character.")

                                              (while (OR (MEMB (\GETBASEPTR CHLIST -2)
                                                               TEDIT.DONT.LAST.CHARS)
                                                         (MEMB CH TEDIT.DONT.BREAK.CHARS))
                                                 do 
                                                    (* ;; 
                                             "This character ch doesn't appear at first of lines. or")

                                                    (* ;; 
                                             "Previous character doesn't appear at the end of lines.")

                                                    (* ;; "So, move previous character to next line.")

                                                    (SETQ CHLIST (\ADDBASE CHLIST -2))
                                                    (SETQ WLIST (\ADDBASE WLIST -2))
                                                    (add TLEN -1)
                                                    (add CHNO -1)
                                                    (SETQ CH (\GETBASEPTR CHLIST 0)))
                                              (freplace (LINEDESCRIPTOR CHARLIM) of LINE
                                                 with (IMAX (SUB1 CHNO)
                                                            CH#1)))
                                             (T              (* ; 
                                                    "Can't split BEFORE the first thing on the line!")
                                                (freplace (LINEDESCRIPTOR CHARLIM) of LINE
                                                   with CHNO)
                                                (\RPLPTR CHLIST 0 CH)
                                                (\RPLPTR WLIST 0 DX)
                                                (CL:WHEN NEWASCENT
                                                             (* ; "The ascent has changed;  catch it")
                                                    (SETQ ASCENT (IMAX ASCENT NEWASCENT))
                                                    (SETQ DESCENT (IMAX DESCENT NEWDESCENT))
                                                    (SETQ NEWASCENT NIL))]
                                          (RETURN))
                                         (T                  (* ; "Not past the rightmargin yet...")
                                            (CL:WHEN NEWASCENT
                                                             (* ; "The ascent has changed;  catch it")
                                                (SETQ ASCENT (IMAX ASCENT NEWASCENT))
                                                (SETQ DESCENT (IMAX DESCENT NEWDESCENT))
                                                (SETQ NEWASCENT NIL))
                                            (\RPLPTR CHLIST 0 CH)
                                            (\RPLPTR WLIST 0 DX)
                                            (SELCHARQ CH
                                                 (%.         (* ; "Check for decimal tabs")
                                                     (CL:WHEN (AND TABPENDING (NOT (FIXP TABPENDING))
                                                                   (EQ (fetch PTTYPE of TABPENDING)
                                                                       'DECIMAL))
                                                             (* ; 
                             "Figure out which tab stop to use, and what we need to do to get there.")
                                                         (add (fetch (PENDINGTAB PTTABX) of 
                                                                                           TABPENDING
                                                                     )
                                                              DX)
                                                             (* ; 
               "Adjust the tab stop's X value so that the LEFT edge of the decimal point goes there.")
                                                         (SETQ TABPENDING
                                                          (\TEDIT.FORMATTABS TEXTOBJ TABSPEC THISLINE
                                                                 CHLIST WLIST TX DEFAULTTAB LEFTEDGE
                                                                 TABPENDING 0 T))
                                                             (* ; 
                                                    "Tab over to the LEFT side of the decimal point.")
                                                         [COND
                                                            ((FIXP TABPENDING)
                                                             (* ; 
                            "If it returns a number, that is the new TX, adjusted for any prior tabs")
                                                             (SETQ TX TABPENDING)
                                                             (SETQ TABPENDING NIL))
                                                            (TABPENDING 
                                                             (* ; 
                                                   "Otherwise, look in the PENDINGTAB for the new TX")
                                                                   (SETQ TX (fetch PTNEWTX
                                                                               of TABPENDING]
                                                         (CL:WHEN GATHERBLANK
                                                             (SETQ TXB1 TX)
                                                             (SETQ GATHERBLANK NIL))
                                                         (SETQ CH#B CHNO)
                                                         (\TEDIT.PURGE.SPACES (fetch (THISLINE CHARS)
                                                                                 of THISLINE)
                                                                PREVSP)
                                                             (* ; 
                         "All the spaces before a tab don't take part in justification from here on.")
                                                         (SETQ %#BLANKS 0)
                                                             (* ; 
                      "Also reset the count of spaces on this line, so we widen later spaces enough.")
                                                         (SETQ PREVSP 0)
                                                         (SETQ T1SPACE T)
                                                         (SETQ TXB TX)
                                                             (* ; 
                              "Remember the world in case this is the 'space' before the line breaks")
                                                         (SETQ DXB DX)
                                                         (SETQ LOOK#B LOOKNO)
                                                         (SETQ ASCENTB ASCENT)
                                                         (SETQ DESCENTB DESCENT)
                                                         (SETQ INVISIBLERUNSB INVISIBLERUNS)))
                                                 ((- "357,045") 
                                                             (* ; "Hyphen, M-dash")
                                                      (SETQ PREVHYPH (ADD1 TLEN))
                                                      (SETQ PREVDHYPH NIL)
                                                      (SETQ TXB1 (SETQ TXB TX))
                                                      (SETQ DXB DX)
                                                      (SETQ LOOK#B LOOKNO)
                                                      (SETQ CH#B CHNO)
                                                      (SETQ ASCENTB ASCENT)
                                                      (SETQ DESCENTB DESCENT)
                                                      (SETQ INVISIBLERUNSB INVISIBLERUNS))
                                                 ("357,042"  (* ; "non-breaking hyphen")
                                                            (\RPLPTR CHLIST 0 (CHARCODE "-")))
                                                 ("357,043"  (* ; "Discretionary hyphen")
                                                             (* ; "And isn't actually displayed.")
                                                            (SETQ PREVDHYPH (ADD1 TLEN))
                                                            (SETQ PREVHYPH NIL)
                                                            (SETQ TXB1 (SETQ TXB TX))
                                                            (SETQ DXB DX)
                                                            (SETQ LOOK#B LOOKNO)
                                                            (SETQ CH#B CHNO)
                                                            (SETQ ASCENTB ASCENT)
                                                            (SETQ DESCENTB DESCENT)
                                                            (SETQ INVISIBLERUNSB INVISIBLERUNS)
                                                            (\RPLPTR WLIST 0 0)
                                                             (* ; 
                                                          "Unless we use it, the prevhyph is 0 wide.")
                                                            (\RPLPTR CHLIST 0 NIL)
                                                            (add TX (IMINUS DX)))
                                                 ("357,041"  (* ; "non-breaking space."))
                                                 NIL]
                    (SETQ CHLIST (\ADDBASE CHLIST 2))        (* ; 
                                                  "Move the pointers forward for the next character.")
                    (SETQ WLIST (\ADDBASE WLIST 2)))

              (* ;; "End of char loop")

              (CL:WHEN (AND (IEQP TLEN (SUB1 (FOLDLO LineArraySize 2)))
                            (ILESSP CHNO TEXTLEN))
                     (TEDIT.PROMPTPRINT TEXTOBJ "Line too long to format." T))
              (CL:WHEN TABPENDING                            (* ; 
                                                         "There is a TAB outstanding.  Go handle it.")
                  (add (fetch (PENDINGTAB PTTABX) of TABPENDING)
                       DX)                                   (* ; 
                          "Adjust the tab stop's X value so that the LEFT edge of the CR goes there.")
                  (SETQ TABPENDING (\TEDIT.FORMATTABS TEXTOBJ TABSPEC THISLINE CHLIST WLIST TX 
                                          DEFAULTTAB LEFTEDGE TABPENDING 0 T))

                  (* ;; "Finish up processing the outstanding TAB.  We get back the new X position, with that taken into account.")

                  (SETQ TX TABPENDING)
                  (SETQ TABPENDING NIL)
                  (\TEDIT.PURGE.SPACES (fetch (THISLINE CHARS) of THISLINE)
                         PREVSP)                             (* ; 
                                              "Don't use the spaces before the TAB in justification.")
                  (SETQ PREVSP 0)))
             (T 
                (* ;; 
                "No starting  PC: empty or beyond the end. Get looks from the TSTREAM or TEXTOBJ.")

                (\EDITSETA LOOKS 0 (fetch (TEXTSTREAM CURRENTLOOKS) of TSTREAM))
                                                             (* ; 
                                     "Set up the initial looks so that \DISPLAYLINE doesn't complain")

                (* ;; "The font we use is preferably the caret looks, else the default for this edit, else the system default")

                (SETQ FONT (OR (AND (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                    (fetch CLFONT of (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)))
                               (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                    (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)))
                               DEFAULTFONT))
                (SETQ ASCENT (FONTPROP FONT 'ASCENT))
                (SETQ DESCENT (FONTPROP FONT 'DESCENT))
                (SETQ FMTSPEC (OR FMTSPEC (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ)))
                (SETQ 1STLN T)
                (SETQ TX (IPLUS 8 (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                (fetch 1STLEFTMAR of FMTSPEC)))
                (replace (LINEDESCRIPTOR LEFTMARGIN) of LINE with TX)
                [SETQ WIDTH (COND
                               ((NOT (ZEROP (fetch RIGHTMAR of FMTSPEC)))
                                (fetch RIGHTMAR of FMTSPEC))
                               (T (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                         8]
                (replace (LINEDESCRIPTOR RIGHTMARGIN) of LINE with WIDTH)
                (SETQ TXB1 WIDTH)))
          (CL:WHEN (ZEROP (freplace (LINEDESCRIPTOR LHEIGHT) of LINE with (IPLUS ASCENT DESCENT)))
              (replace (LINEDESCRIPTOR LHEIGHT) of LINE
                 with (FONTPROP (OR (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                         (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                             of TEXTOBJ)))
                                    DEFAULTFONT)
                             'HEIGHT)))                      (* ; 
                                                            "Line's height (or 12 for an empty line)")
          (replace (LINEDESCRIPTOR ASCENT) of LINE with ASCENT)
          (replace (LINEDESCRIPTOR DESCENT) of LINE with DESCENT)
          (freplace (LINEDESCRIPTOR CHARTOP) of LINE with CHNO)
          (CL:UNLESS FORCEEND (add CHNO -1))                 (* ; 
                          "If we ran off the end of the text, then keep true space left on the line.")
          (freplace (LINEDESCRIPTOR LXLIM) of LINE with TX)
          [freplace (LINEDESCRIPTOR SPACELEFT) of LINE with (COND
                                                               (FORCEEND 
                                                             (* ; 
                                "The line was forced to end.  Back up to start of last blank section")
                                                                      (IDIFFERENCE WIDTH TXB1))
                                                               (GATHERBLANK 
                                                             (* ; 
                                                "Otherwise, use the rightmost character on the line.")
                                                                      (IDIFFERENCE WIDTH TX))
                                                               (T 

                                         (* ;; "The line ended with a run of white space.  Ignore it for purposes of deciding how much more we can fit on the line.")

                                                                  (IDIFFERENCE WIDTH TXB1]
          (freplace (THISLINE DESC) of THISLINE with LINE)
          [freplace (THISLINE LEN) of THISLINE
             with (IMIN (- (FOLDLO LineArraySize 2)
                           2)
                        (COND
                           ((ILESSP TEXTLEN CH#1)
                            -1)
                           (T (IPLUS LOOKNO (IDIFFERENCE (IMIN (fetch (LINEDESCRIPTOR CHARLIM)
                                                                  of LINE)
                                                               TEXTLEN)
                                                   (IPLUS INVISIBLERUNS (fetch (LINEDESCRIPTOR CHAR1)
                                                                           of LINE]
          (\DOFORMATTING TEXTOBJ LINE (OR ORIGFMTSPEC FMTSPEC)
                 THISLINE %#BLANKS PREVSP 1STLN)
          (replace (LINEDESCRIPTOR LFMTSPEC) of LINE with FMTSPEC)
          (replace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with NIL)
          (RETURN LINE])

(\FORMATLINE.NEWNSCHARS
  [LAMBDA (CH TEXTOBJ)                                       (* ; "Edited  1-Aug-2022 20:09 by rmk")
    (CL:WHEN (AND (EQ CH (CHARCODE NSCHARSETSHIFT))
                  (NOT (ffetch (TEXTOBJ TXTNONSCHARS) of TEXTOBJ)))

        (* ;; "Character-set change character.  This suggests undetected NS characters.")

        (HELP "PIECES SHOULD NOT CONTAIN NSCHARS")
        (\TEDIT.NSCHAR.RUN CHNO TEXTOBJ TEXTSTREAM)          (* ; 
                                                    "Leaves us ready to BIN again at the same place.")

        (* ;; "Back up the cache pointers and counters so that when we go to the top of the loop we're where we are now.")

        (SETQ CHLIST (\ADDBASE CHLIST -2))
        (SETQ WLIST (\ADDBASE WLIST -2))
        (add CHNO -1)
        (add TLEN -1)

        (* ;; "Because moving to NS characters changes the TEXTLEN for the shorter.")

        (SETQ TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
        T)])

(\TEDIT.NSCHAR.RUN
  [LAMBDA (CHNO TEXTOBJ STREAM)                              (* ; "Edited  9-Sep-2022 17:01 by rmk")
                                                             (* ; "Edited 23-Aug-2022 11:56 by rmk")
                                                             (* ; "Edited  6-Aug-2022 08:46 by rmk")
                                                             (* ; "Edited 24-Jul-2022 09:21 by rmk")
                                                             (* ; "Edited 29-Apr-93 16:42 by jds")

    (* ;; "Given that we've just BIN'd from TEXTOBJ at character # CHNO and it was a 255, rearrange the piece table so that NS characters are available transparently %"as far ahead as makes sense%".")

    (* ;; "Leave TEXTOBJ ready to BIN at CHNO again, so the line formatter can carry on.")

    (LET [PC START-OF-PIECE OFFSET PLEN CH NEXTCH PFPOS NEWPLEN PF PS CHARSET TFILE
             (OLDFILEPTR (SUB1 (GETFILEPTR STREAM]
         (SETQ PC (\CHTOPC CHNO TEXTOBJ T))
         (SETQ OFFSET (- CHNO START-OF-PIECE))
         (SETQ PLEN (fetch (PIECE PLEN) of PC))
         (COND
            ((EQ FATFILE2.PTYPE (PTYPE PC))
             (HELP "Hit charset change in a FAT piece")))
         (replace (TEXTOBJ HINTPC) of TEXTOBJ with NIL)      (* ; "Back up over the NSCHARSETSHIFT")
         (SETQ CH (BIN STREAM))
         [COND
            [(EQ CH \NORUNCODE)                              (* ; "A steady run of fat characters.")
             (COND
                ((SETQ PS (fetch (PIECE PCONTENTS) of PC))   (* ; "This piece is in a string.")
                 (HELP "NS characters in a STRING??"))
                ((SETQ PF (fetch (PIECE PCONTENTS) of PC))   (* ; "This piece is in a file.")
                 (SETQ PFPOS (fetch (PIECE PFPOS) of PC))
                 (SETQ NEXTCH (FILEPOS (CHARACTER NSCHARSETSHIFT)
                                     PF
                                     (IPLUS OFFSET PFPOS 3)
                                     (IPLUS PFPOS PLEN)))    (* ; 
                                                          "Find the succeeding 255, or end of piece.")
                 [SETQ NEWPLEN (COND
                                  (NEXTCH (IQUOTIENT (IDIFFERENCE NEXTCH (IPLUS PFPOS OFFSET 3))
                                                 2))
                                  (T (IQUOTIENT (IDIFFERENCE (IDIFFERENCE PLEN OFFSET)
                                                       3)
                                            2]
                 (\DELETECH (IPLUS START-OF-PIECE OFFSET)
                        (IPLUS START-OF-PIECE OFFSET 5 (ITIMES NEWPLEN 2))
                        TEXTOBJ T)
                 (\TEDIT.INSERT.PIECES TEXTOBJ (IPLUS START-OF-PIECE OFFSET)
                        (create PIECE using PC PCONTENTS _ PF PFPOS _ (IPLUS PFPOS OFFSET 3)
                                            PTYPE _ FATFILE2.PTYPE PLEN _ NEWPLEN)
                        NEWPLEN NIL NIL T)
                 (add (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)
                      NEWPLEN]
            (T                                               (* ; 
                                         "Changing to a new character set for succeeding characters.")
               (CL:WHEN (AND NIL (SETQ PS (fetch (PIECE PCONTENTS) of PC)))
                                                             (* ; 
                                                            "Not a problem when strings are not XCCS")
                   (HELP "NS characters in a STRING??"))
               (COND
                  ((SETQ PF (fetch (PIECE PCONTENTS) of PC)) (* ; "This piece is in a file.")
                   (SETQ CHARSET CH)
                   (SETQ PFPOS (fetch (PIECE PFPOS) of PC))
                   (SETQ NEXTCH (FILEPOS (CHARACTER \NORUNCODE)
                                       PF
                                       (IPLUS OFFSET PFPOS 2)
                                       (IPLUS PFPOS PLEN)))  (* ; 
                                                          "Find the succeeding 255, or end of piece.")
                   [SETQ NEWPLEN (COND
                                    ((ZEROP CHARSET)         (* ; "If we're moving back to charset 0, we just want to delete the charset change marker, so the newPlen is 0.")
                                     0)
                                    (NEXTCH (IDIFFERENCE NEXTCH (IPLUS OFFSET PFPOS 2)))
                                    (T (IDIFFERENCE (IDIFFERENCE PLEN OFFSET)
                                              2]
                   (\DELETECH (IPLUS START-OF-PIECE OFFSET)
                          (IPLUS START-OF-PIECE OFFSET 2 NEWPLEN)
                          TEXTOBJ T)
                   (COND
                      ((ZEROP NEWPLEN)                       (* ; 
              "Do nothing if there weren't really any characters to be put in the new character set.")
                       )
                      ((ZEROP CHARSET)                       (* ; 
                                            "Do nothing if we're switching back to normal character.")
                       )
                      (T                                     (* ; "There really are characters to be moved to the new character set.  Create the temporary file for them.")

                         (* ;; "Create the file")

                         (SETQ TFILE (OPENSTREAM '{NODIRCORE} 'BOTH))
                         (SETFILEPTR PF (IPLUS OFFSET PFPOS 2))
                         (for I from 1 to NEWPLEN do 
                                                     (* ;; 
                                             "Copy the newly fattened characters into the temp file.")

                                                     (BOUT TFILE CHARSET)
                                                     (BOUT TFILE (BIN PF)))

                         (* ;; "Insert a new piece in the document holding the fat characters.")

                         (\TEDIT.INSERT.PIECES TEXTOBJ (IPLUS START-OF-PIECE OFFSET)
                                (create PIECE
                                   using PC PCONTENTS _ TFILE PFPOS _ 0 PTYPE _ FATFILE2.PTYPE PLEN _
                                         NEWPLEN)
                                1 NIL NIL T)
                         (add (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)
                              NEWPLEN]
         (\SETUPGETCH CHNO TEXTOBJ])

(\TEDIT.PURGE.SPACES
  [LAMBDA (CHLIST PREVSP)                                    (* jds " 9-NOV-83 17:12")
    (bind OPREVSP while (IGREATERP PREVSP 0) do (SETQ OPREVSP (SUB1 PREVSP))
                                                (SETQ PREVSP (\EDITELT CHLIST OPREVSP))
                                                (\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE])

(\DOFORMATTING
  [LAMBDA (TEXTOBJ LINE FMTSPEC THISLINE %#BLANKS PREVSP 1STLN)
                                                             (* ; "Edited 29-Mar-94 12:36 by jds")
                                                             (* ; 
                                        "Do the formatting work for justified, centered, etc.  lines")
    (PROG ((QUAD (fetch QUAD of FMTSPEC))
           (SPACELEFT (LLSH (fetch (LINEDESCRIPTOR SPACELEFT) of LINE)
                            5))
           (EXISTINGSPACE 0)
           (CHLIST (fetch (THISLINE CHARS) of THISLINE))
           (WLIST (fetch (THISLINE WIDTHS) of THISLINE))
           (SPACEOFLOW 0)
           EXTRASP OPREVSP LINELEAD)                         (* ; 
                    "NB that SPACELEFT, OFLOW, etc.  are kept in 32 x value form, for rounding ease.")
          (replace (LINEDESCRIPTOR LTRUEDESCENT) of LINE with (fetch (LINEDESCRIPTOR DESCENT)
                                                                 of LINE))
          (replace (LINEDESCRIPTOR LTRUEASCENT) of LINE with (fetch (LINEDESCRIPTOR ASCENT)
                                                                of LINE))
                                                             (* ; 
                                                    "Save the true ascent value for display purposes")
          (replace (THISLINE TLSPACEFACTOR) of THISLINE with 1)
                                                             (* ; 
                                               "Start by assuming that we want a space factor of 1.0")
          [COND
             ((SETQ LINELEAD (fetch LINELEAD of FMTSPEC))    (* ; 
                                                             "If line leading was specified, set it")
              (COND
                 (T (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                         (fetch LINELEAD of FMTSPEC))        (* ; 
                                                          "And adjust the line's descent accordingly")
                    (add (fetch (LINEDESCRIPTOR DESCENT) of LINE)
                         (fetch LINELEAD of FMTSPEC]
          [COND
             ((AND 1STLN (fetch LEADBEFORE of FMTSPEC))      (* ; 
                                                     "If paragraph pre-leading was specified, set it")
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   (fetch LEADBEFORE of FMTSPEC))            (* ; 
                                                          "And adjust the line's ascent accordingly.")
              (add (fetch (LINEDESCRIPTOR ASCENT) of LINE)
                   (fetch LEADBEFORE of FMTSPEC]
          [COND
             ((AND (fetch (LINEDESCRIPTOR LSTLN) of LINE)
                   (fetch LEADAFTER of FMTSPEC))             (* ; 
                                                     "If paragraph pre-leading was specified, set it")
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   (fetch LEADAFTER of FMTSPEC))             (* ; 
                                                          "And adjust the line's ascent accordingly.")
              (add (fetch (LINEDESCRIPTOR DESCENT) of LINE)
                   (fetch LEADAFTER of FMTSPEC]
          (SELECTQ QUAD
              (LEFT                                          (* ; 
                             "Do nothing for left-justified lines except replace the character codes"))
              (RIGHT                                         (* ; "Just move the right margin over")
                     (replace (LINEDESCRIPTOR LEFTMARGIN) of LINE with (IPLUS (fetch (LINEDESCRIPTOR
                                                                                      LEFTMARGIN)
                                                                                 of LINE)
                                                                              (fetch (LINEDESCRIPTOR
                                                                                      SPACELEFT)
                                                                                 of LINE)))
                     (replace (LINEDESCRIPTOR LXLIM) of LINE with (fetch (LINEDESCRIPTOR RIGHTMARGIN)
                                                                     of LINE))
                     (COND
                        ((OR (ILESSP (fetch (THISLINE LEN) of THISLINE)
                                    0)
                             (ZEROP %#BLANKS)
                             (ZEROP PREVSP))                 (* ; 
                       "For empty lines, and lines with no spaces, don't bother fixing blank widths.")
                         (RETURN))))
              (CENTERED                                      (* ; 
                                                             "Split the difference for centering")
                        (add (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
                             (LRSH SPACELEFT 6))
                        (add (fetch (LINEDESCRIPTOR LXLIM) of LINE)
                             (LRSH SPACELEFT 6))
                        (COND
                           ((OR (ILESSP (fetch (THISLINE LEN) of THISLINE)
                                       0)
                                (ZEROP %#BLANKS)
                                (ZEROP PREVSP))              (* ; 
                       "For empty lines, and lines with no spaces, don't bother fixing blank widths.")
                            (RETURN))))
              (JUSTIFIED                                     (* ; 
                           "For justified lines, stretch each space so line reaches the right margin")
                         (COND
                            ((OR (ILESSP (fetch (THISLINE LEN) of THISLINE)
                                        0)
                                 (ZEROP %#BLANKS)
                                 (ZEROP PREVSP))             (* ; 
                       "For empty lines, and lines with no spaces, don't bother fixing blank widths.")
                             (RETURN)))
                         (COND
                            ((OR (fetch (LINEDESCRIPTOR CR\END) of LINE)
                                 (IGEQ (fetch (LINEDESCRIPTOR CHARLIM) of LINE)
                                       (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
                                                             (* ; 
                                     "This is the last line in the paragraph;  don't stretch it out.")
                             (SETQ EXTRASP 0))
                            ((IEQP PREVSP (ADD1 (fetch (THISLINE LEN) of THISLINE)))
                                                             (* ; 
   "Only if the last character on the line is a space should we remove trailing spaces from the list")
                             (bind (OPREVSP _ (SUB1 PREVSP)) while (AND (IGREATERP PREVSP 0)
                                                                        (ILEQ OPREVSP PREVSP))
                                do 

                                 (* ;; "Back up over all trailing white space on the line.  So that those blanks don't get counted when computing the space to be added to each REAL space on the line, when it is justified.")

                                   (SETQ OPREVSP (SUB1 PREVSP))
                                   (SETQ PREVSP (\EDITELT CHLIST OPREVSP))
                                   (\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE)))
                                   (add %#BLANKS -1))
                             (COND
                                ((ZEROP %#BLANKS)            (* ; 
                      "If there aren't any blanks except at end-of-line, don't bother going further.")
                                 (RETURN)))
                             (replace (LINEDESCRIPTOR LXLIM) of LINE with (fetch (LINEDESCRIPTOR
                                                                                  RIGHTMARGIN)
                                                                             of LINE))
                                                             (* ; 
                                                     "Fix the right margin for showing selections &c")
                             (SETQ EXTRASP (IQUOTIENT SPACELEFT %#BLANKS))
                                                             (* ; 
                                                 "Now apportion the extra space evenly among blanks.")
                             )
                            (T 
                               (* ;; 
          "NO SPACE AT END OF LINE -- LINE ENDS IN HYPHEN, ETC, OR MAYBE IS TOO LONG WITH NO SPACES.")

                               (COND
                                  ((ZEROP %#BLANKS)          (* ; 
                                            "If there aren't any blanks, don't bother going further.")
                                   (RETURN)))
                               (replace (LINEDESCRIPTOR LXLIM) of LINE with (fetch (LINEDESCRIPTOR
                                                                                    RIGHTMARGIN)
                                                                               of LINE))
                                                             (* ; 
                                                     "Fix the right margin for showing selections &c")
                               (SETQ EXTRASP (IQUOTIENT SPACELEFT %#BLANKS))
                                                             (* ; 
                                                 "Now apportion the extra space evenly among blanks.")
                               ))
                         [while (IGREATERP PREVSP 0)
                            do                               (* ; 
                                                            "Fix up the widths of spaces in the line")
                               (SETQ OPREVSP (SUB1 PREVSP))
                               (SETQ PREVSP (\EDITELT CHLIST OPREVSP))
                               (add EXISTINGSPACE (\EDITELT WLIST OPREVSP))
                               (\EDITSETA CHLIST OPREVSP (CONSTANT (CHARCODE SPACE)))
                               [OR (fetch (LINEDESCRIPTOR CR\END) of LINE)
                                   (\EDITSETA WLIST OPREVSP (IPLUS (LRSH (IPLUS EXTRASP SPACEOFLOW)
                                                                         5)
                                                                   (\EDITELT WLIST OPREVSP]
                               (SETQ SPACEOFLOW (LOGAND 31 (IPLUS EXTRASP SPACEOFLOW]
                         (COND
                            ([AND (NOT (ZEROP EXISTINGSPACE))
                                  (OR (NOT (ZEROP EXTRASP))
                                      (NOT (ZEROP (fetch (LINEDESCRIPTOR SPACELEFT) of LINE]
                                                             (* ; "Only if we really expanded the line -- and there are spaces to expand (or else EXISTINGSPACE is 0).")
                             (replace (THISLINE TLSPACEFACTOR) of THISLINE
                                with (FQUOTIENT (IPLUS EXISTINGSPACE (fetch (LINEDESCRIPTOR SPACELEFT
                                                                                   ) of LINE))
                                            EXISTINGSPACE))  (* ; 
                                                             "And set the space factor for display")
                             )
                            (T                               (* ; "Pathological cases ")
                               (replace (THISLINE TLSPACEFACTOR) of THISLINE with 1)))
                         (RETURN))
              NIL)
          (\TEDIT.PURGE.SPACES CHLIST PREVSP)                (* ; 
  "Change all the spaces--chained for justification--back into regular spaces, for the display code.")
      ])
)
(DEFINEQ

(\DISPLAYLINE
  [LAMBDA (TEXTOBJ LINE WINDOW)                              (* ; "Edited  9-Sep-2022 22:39 by rmk")
                                                            (* ; "Edited 28-Sep-2021 15:00 by rmk:")

    (* ;; "Display the line of text LINE in the edit window where it belongs.")

    (* ;; "Validate the incoming arguments so ffetch can be used consistently for all their field extractions.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (\DTEST LINE 'LINEDESCRIPTOR)
    (LET ((LOOKS (ffetch (THISLINE LOOKS) of (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)))
          (WINDOWDS (WINDOWPROP (OR WINDOW (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ)))
                           'DSP))
          (THISLINE (\DTEST (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)
                           'THISLINE))
          (OLDCACHE (fetch (LINECACHE LCBITMAP) of (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)))
          (DS (ffetch (TEXTOBJ DISPLAYCACHEDS) of TEXTOBJ))
          (HCPYDS (ffetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ))
          (HARDCOPYMODE (fetch (FMTSPEC FMTHARDCOPY) of (ffetch (LINEDESCRIPTOR LFMTSPEC)
                                                           of LINE)))
          CACHE OFONT OLOOKS XOFFSET CLIPLEFT CLIPRIGHT DISPLAYDATA DDPILOTBBT DDWIDTHCACHE 
          DDOFFSETCACHE CURY LHEIGHT SCALE)
         [SETQ LHEIGHT (COND
                          ((ffetch (LINEDESCRIPTOR PREVLINE) of LINE)
                                                             (* ; 
                                    "So if theres a base-to-base measure, we clear everything right.")
                           (IMAX (IDIFFERENCE (ffetch (LINEDESCRIPTOR YBOT)
                                                 of (ffetch (LINEDESCRIPTOR PREVLINE) of LINE))
                                        (ffetch (LINEDESCRIPTOR YBOT) of LINE))
                                 (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE)))
                          (T (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE]
         (SETQ SCALE (COND
                        (HARDCOPYMODE                        (* ; 
                                                       "This is a hardcopy-mode line.  Scale things.")
                               (DSPSCALE NIL HCPYDS))
                        (T 1)))
         (SETQ CACHE (\TEDIT.LINECACHE (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)
                            (COND
                               (HARDCOPYMODE (FIXR (FQUOTIENT (ffetch (LINEDESCRIPTOR RIGHTMARGIN)
                                                                 of LINE)
                                                          SCALE)))
                               (T (ffetch (LINEDESCRIPTOR RIGHTMARGIN) of LINE)))
                            LHEIGHT))
         (COND
            ((NEQ CACHE OLDCACHE)                            (* ; 
                 "We changed the bitmaps because this line was bigger--update the displaystream, too")
             (DSPDESTINATION CACHE DS)
             (DSPCLIPPINGREGION (create REGION
                                       LEFT _ 0
                                       BOTTOM _ 0
                                       WIDTH _ (fetch BITMAPWIDTH of CACHE)
                                       HEIGHT _ (fetch BITMAPHEIGHT of CACHE))
                    DS)))
         (BITBLT NIL 0 0 CACHE 0 0 NIL NIL 'TEXTURE 'REPLACE WHITESHADE)
                                                             (* ; "Clear the line cache")
         [COND
            ((AND (NOT (ZEROP (fetch (LINEDESCRIPTOR CHAR1) of LINE)))
                  (ILEQ (ffetch (LINEDESCRIPTOR CHAR1) of LINE)
                        (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                  (IGEQ (ffetch (LINEDESCRIPTOR YBOT) of LINE)
                        (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))

             (* ;; "Only display the line if it contains text (CHAR1 > 0), appears before the end of the text, and is on-screen.")

             (CL:WHEN (EQ (fetch (THISLINE DESC) of THISLINE)
                          LINE)                              (* ; 
                                                            "No image cache -- re-format and display")
                 (\FORMATLINE TEXTOBJ NIL (ffetch (LINEDESCRIPTOR CHAR1) of LINE)
                        LINE))
             (MOVETO (ffetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
                    (ffetch (LINEDESCRIPTOR DESCENT) of LINE)
                    DS)
             (SETQ DISPLAYDATA (fetch (STREAM IMAGEDATA) of DS))
             (SETQ DDPILOTBBT (ffetch DDPILOTBBT of DISPLAYDATA))
             (SETQ XOFFSET (fetch DDXOFFSET of DISPLAYDATA))

             (* ;; "The X position of the left edge of the window, since \TEDIT.BLTCHAR works on the screen bitmap itself.")

             (SETQ CLIPLEFT (fetch DDClippingLeft of DISPLAYDATA))
                                                             (* ; 
                       "The left and right edges of the clipping region for the text display window.")
             (SETQ CLIPRIGHT (fetch DDClippingRight of DISPLAYDATA))
             (SETQ OFONT (DSPFONT (fetch CLFONT of (SETQ OLOOKS (\EDITELT LOOKS 0)))
                                DS))                         (* ; "The starting font")
             (SETQ DDWIDTHCACHE (ffetch DDWIDTHSCACHE of DISPLAYDATA))
                                                             (* ; "Cache the character-image widths")
             (SETQ DDOFFSETCACHE (ffetch DDOFFSETSCACHE of DISPLAYDATA))
                                                             (* ; 
                                                            "And the offset-into-strike-bitmap array")
                                                             (* ; 
                                        "LOOKSTARTX: Starting X position for the current-looks text.")
             (CL:WHEN (fetch CLOFFSET of OLOOKS)
                 (RELMOVETO 0 (FIXR (FTIMES SCALE (fetch CLOFFSET of OLOOKS)))
                        DS))                                 (* ; 
                                                        "Any sub- or superscripting at start of line")
             (bind (LOOKNO _ 1)
                   DX CH (CHLIST _ (fetch (THISLINE CHARS) of (ffetch (TEXTOBJ THISLINE) of TEXTOBJ))
                                )
                   (WLIST _ (fetch (THISLINE WIDTHS) of (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)))
                   (TX _ (IPLUS XOFFSET (ffetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)))
                   (TERMSA _ (ffetch (TEXTOBJ TXTTERMSA) of TEXTOBJ))
                   (LOOKSTARTX _ (ffetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)) for I from 0
                to (ffetch (THISLINE LEN) of THISLINE)
                do 
                   (* ;; "Display the line character by character")

                   (SETQ CH (\EDITELT CHLIST I))             (* ; 
                                                        "Grab the character (or IMAGEOBJ) to display")
                   (SETQ DX (\EDITELT WLIST I))              (* ; "And its width")
                   [SELECTC CH
                       (LMInvisibleRun                       (* ; 
                                          "An INVISIBLE run -- skip it, and skip over the char count")
                            (add LOOKNO 1))
                       (LMLooksChange                        (* ; "A LOOKS change")
                                      (replace DDXPOSITION of DISPLAYDATA with (IDIFFERENCE TX 
                                                                                      XOFFSET))
                                                             (* ; 
                                              "Make the displaystream reflect our current X position")
                                      (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS OLOOKS
                                             (ffetch (LINEDESCRIPTOR DESCENT) of LINE))
                                                             (* ; 
                  "Make any necessary changes to the preceding characters (underline, strike-out &c)")
                                      (DSPFONT (fetch CLFONT of (SETQ OLOOKS (\EDITELT LOOKS LOOKNO))
                                                      )
                                             DS)             (* ; "Set the new font")
                                      (add LOOKNO 1)         (* ; "Grab the next set of char looks")
                                      (AND (fetch CLOFFSET of OLOOKS)
                                           (RELMOVETO 0 (fetch CLOFFSET of OLOOKS)
                                                  DS))       (* ; "Account for super/subscripting")
                                      (SETQ LOOKSTARTX (IDIFFERENCE TX XOFFSET))
                                                             (* ; 
                                       "Remember the starting Xpos for possible later underlining &c")
                                      )
                       ((CHARCODE (TAB %#^I))                (* ; 
                                  "TAB: use the width from the cache to decide the right formatting.")
                            [COND
                               ((OR (IEQP CH (CHARCODE %#^I))
                                    (fetch CLLEADER of OLOOKS)
                                    (EQ (fetch CLUSERINFO of OLOOKS)
                                        'DOTTEDLEADER))
                                (LET* [[LEADERFONT (COND
                                                      (HARDCOPYMODE (FONTCOPY (fetch CLFONT
                                                                                 of OLOOKS)
                                                                           'DEVICE HCPYDS))
                                                      (T (fetch CLFONT of OLOOKS]
                                       (DOTWIDTH (CHARWIDTH (CHARCODE %.)
                                                        LEADERFONT))
                                       (TTX (IPLUS TX DOTWIDTH (IDIFFERENCE DOTWIDTH (IREMAINDER
                                                                                      TX DOTWIDTH]
                                      (while (ILEQ TTX (IPLUS TX DX))
                                         do (COND
                                               (HARDCOPYMODE (MI-TEDIT.BLTCHAR
                                                              (CHARCODE %.)
                                                              DS
                                                              (FIXR (FQUOTIENT (IDIFFERENCE TTX 
                                                                                      DOTWIDTH)
                                                                           SCALE))
                                                              DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                                               ((OR TERMSA HARDCOPYMODE)
                                                             (* ; "Using special instrns from TERMSA")
                                                (\DSPPRINTCHAR DS (CHARCODE %.)))
                                               (T            (* ; "Native charcodes")
                                                  (MI-TEDIT.BLTCHAR (CHARCODE %.)
                                                         DS
                                                         (IDIFFERENCE TTX DOTWIDTH)
                                                         DISPLAYDATA DDPILOTBBT CLIPRIGHT)))
                                            (add TTX DOTWIDTH])
                       ((CHARCODE (EOL LF CR))               (* ; "It's a CR")
                            NIL)
                       (NIL                                  (* ; "NIL signifies a character we've suppressed as part of line formatting (e.g., a discretionary hyphen we didn't use to break the line).  Show it as a thin black line.")
                            (BLTSHADE BLACKSHADE DS TX 0 1 100 'PAINT))
                       (COND
                          [(SMALLP CH)                       (* ; 
                                                             "Normal character -- just display it.")
                           (COND
                              (HARDCOPYMODE (MI-TEDIT.BLTCHAR CH DS (FIXR (FQUOTIENT TX SCALE))
                                                   DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                              ((OR TERMSA HARDCOPYMODE)      (* ; "Using special instrns from TERMSA")
                               (\DSPPRINTCHAR DS CH))
                              (T                             (* ; "Native charcodes")
                                 (MI-TEDIT.BLTCHAR CH DS TX DISPLAYDATA DDPILOTBBT CLIPRIGHT]
                          (T                                 (* ; "CH is an object.")
                             (MOVETO (IDIFFERENCE (FIXR (FQUOTIENT TX SCALE))
                                            XOFFSET)
                                    (SETQ CURY (DSPYPOSITION NIL DS))
                                    DS)                      (* ; 
                                                "Go to the base line, left edge of the image region.")
                             (APPLY* (IMAGEOBJPROP CH 'DISPLAYFN)
                                    CH DS 'DISPLAY (ffetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                                                             (* ; "Tell him to display himself here.")
                             (DSPFONT (fetch CLFONT of OLOOKS)
                                    DS)
                             (MOVETO (IDIFFERENCE (FIXR (FQUOTIENT TX SCALE))
                                            XOFFSET)
                                    CURY DS)                 (* ; "Move to after the object's image")
                             ]
                   (add TX DX)                               (* ; "Update our X position")
                finally (replace DDXPOSITION of DISPLAYDATA with (IDIFFERENCE (FIXR (FQUOTIENT TX 
                                                                                           SCALE))
                                                                        XOFFSET)) 
                                                             (* ; 
                                        "Make any necessary looks mods to the last run of characters")
                      (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS OLOOKS (ffetch (LINEDESCRIPTOR DESCENT)
                                                                      of LINE]
         (BITBLT CACHE 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBOT) of LINE)
                (ffetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                LHEIGHT
                'INPUT
                'REPLACE)                                    (* ; 
                          "Paint the cached image on the screen (this lessens flicker during update)")
         (COND
            ((fetch (FMTSPEC FMTREVISED) of (ffetch (LINEDESCRIPTOR LFMTSPEC) of LINE))
                                                             (* ; 
                                                       "This paragraph has been revised, so mark it.")
             (\TEDIT.MARK.REVISION TEXTOBJ (ffetch (LINEDESCRIPTOR LFMTSPEC) of LINE)
                    WINDOWDS LINE)))
         (SELECTQ (ffetch (LINEDESCRIPTOR LMARK) of LINE)
             (GREY                                           (* ; 
                "This line has some property that isn't visible to the user.  Tell him to be careful")
                   (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                          6 6 'TEXTURE 'PAINT 42405))
             (SOLID                                          (* ; 
                "This line has some property that isn't visible to the user.  Tell him to be careful")
                    (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                           6 6 'TEXTURE 'PAINT BLACKSHADE))
             (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                    6 6 'TEXTURE 'REPLACE WHITESHADE])

(\TEDIT.LINECACHE
  [LAMBDA (CACHE WIDTH HEIGHT)                               (* jds "21-Apr-84 00:52")

         (* Given a candidate line cache, return the bitmap, making sure it's at least 
         WIDTH by HEIGHT big.)

    (PROG ((BITMAP (fetch LCBITMAP of CACHE))
           CW CH)
          (SETQ CW (fetch BITMAPWIDTH of BITMAP))
          (SETQ CH (fetch BITMAPHEIGHT of BITMAP))
          (COND
             ((AND (IGEQ CW WIDTH)
                   (IGEQ CH HEIGHT))
              (RETURN BITMAP))
             (T (RETURN (replace LCBITMAP of CACHE with (BITMAPCREATE (IMAX CW WIDTH)
                                                               (IMAX CH HEIGHT])

(\TEDIT.CREATE.LINECACHE
  [LAMBDA (%#CACHES)                                         (* jds "21-Apr-84 00:58")
                                                             (* Create a linked-together set of 
                                                             LINECACHEs, for saving line images.)
    (PROG [(CACHES (for I from 1 to %#CACHES collect (create LINECACHE
                                                            LCBITMAP _ (BITMAPCREATE 100 15]
          [for CACHE on CACHES do                            (* Link the caches together.)
                                  (replace LCNEXTCACHE of (CAR CACHE) with (OR (CADR CACHE)
                                                                               (CAR CACHES]
          (RETURN CACHES])

(\TEDIT.BLTCHAR
  [LAMBDA (CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                                             (* jds " 9-Jan-86 17:14")

         (* Version of BLTCHAR peculiar to TEdit --
         relies on \DISPLAYLINE to make sure things keep working right.)

         (* puts a character on a guaranteed display stream.
         Much of the information needed by the BitBlt microcode is prestored by the 
         routines that change it. This is kept in the BitBltTable.)
                                                             (* knows about the representation of 
                                                             display stream image data)
                                                             (* MUST NOT POINT AT A WINDOW'S 
                                                             DISPLAYSTREAM!!!)

         (* ASSUMES THAT WE NEVER WANT TO PRINT TO THE LEFT OF ORIGIN 0 ON THE LINE CACHE 
         BITMAP, OR THAT IF WE DO, ALL BETS ARE OFF)

    (DECLARE (LOCALVARS . T))
    (PROG (NEWX LEFT RIGHT IMAGEWIDTH (CHAR8CODE (\CHAR8CODE CHARCODE)))
          [COND
             ((NEQ (ffetch DDCHARSET of DISPLAYDATA)
                   (\CHARSET CHARCODE))
              (\CHANGECHARSET.DISPLAY DISPLAYDATA (\CHARSET CHARCODE]
          (SETQ IMAGEWIDTH (\GETBASE (fetch DDCHARIMAGEWIDTHS of DISPLAYDATA)
                                  (\CHAR8CODE CHARCODE)))
          (SETQ NEWX (IPLUS CURX IMAGEWIDTH))
          (SETQ LEFT (IMAX 0 CURX))
          (SETQ RIGHT (IMIN CLIPRIGHT NEWX))
          (COND
             ((ILESSP LEFT RIGHT)                            (* Only print anything if there is a 
                                                             place to put it)
              (UNINTERRUPTABLY
                  (freplace PBTDESTBIT of DDPILOTBBT with LEFT)
                                                             (* Set up the bitblt-table source left)
                  (freplace PBTWIDTH of DDPILOTBBT with (IMIN IMAGEWIDTH (IDIFFERENCE RIGHT LEFT)))
                  (freplace PBTSOURCEBIT of DDPILOTBBT with (\GETBASE (fetch DDOFFSETSCACHE
                                                                         of DISPLAYDATA)
                                                                   (\CHAR8CODE CHARCODE)))
                  (\PILOTBITBLT DDPILOTBBT 0))
              T])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS MI-TEDIT.BLTCHAR MACRO [(CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                  (COND
                                     ((EQ 'MAIKO (MACHINETYPE))
                                      (SUBRCALL TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA
                                             DDPILOTBBT CLIPRIGHT))
                                     (T (\TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA 
                                               DDPILOTBBT CLIPRIGHT])
)
)
(DEFINEQ

(TEDIT.CR.UPDATESCREEN
  [LAMBDA (CH# XPOINT TEXTOBJ SEL LINE BLANKSEEN CRSEEN DS CHWIDTH DONTSCROLL)
                                                             (* ; "Edited 23-Feb-88 11:12 by jds")

    (* ;; "Update the edit window image after a CR is typed.  Move any text after the CR to a new line, and push or pull text as needed.")

    (* ;; "(PROG ((WINDOW (fetch \WINDOW of TEXTOBJ)) (PREVLINE (fetch PREVLINE of LINE))) (COND ((AND (NOT (fetch CR\END of PREVLINE)) (ILEQ (IDIFFERENCE XPOINT (fetch LEFTMARGIN of LINE)) (IDIFFERENCE (fetch RIGHTMARGIN of PREVLINE) (fetch LXLIM of PREVLINE)))) (* This CR should push the start of the line back upward.) (replace DIRTY of PREVLINE with T) (replace TXTNEEDSUPDATE of TEXTOBJ with T))) (TEDIT.UPDATE.SCREEN TEXTOBJ PREVLINE T) (\FIXSEL SEL TEXTOBJ) (\SHOWSEL SEL NIL T) (COND (DONTSCROLL (* SO DO NOTHING)) ((OR (NOT (fetch NEXTLINE of LINE)) (ILEQ (fetch YBOT of (fetch NEXTLINE of LINE)) (fetch BOTTOM of (DSPCLIPPINGREGION NIL WINDOW)))) (* This pushed the caret off-screen.  Move it up.) (replace EDITOPACTIVE of TEXTOBJ with NIL) (SCROLLW WINDOW 0 (LLSH (fetch LHEIGHT of (COND ((fetch NEXTLINE of LINE)) (LINE))) 1)))))")

    (HELP])

(TEDIT.DELETELINE
  [LAMBDA (LINE TEXTOBJ WINDOW)                              (* ; "Edited 30-May-91 15:58 by jds")

         (* Remove a complete text line descriptor from the edit window, then move lower 
         lines up over it.)

    (PROG ((PREV (fetch (LINEDESCRIPTOR PREVLINE) of LINE))
           (NEXT (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))) (* Fix up the line-descriptor chain to 
                                                             dis-include line)
          (COND
             (PREV (replace (LINEDESCRIPTOR NEXTLINE) of PREV with NEXT)))
          (COND
             (NEXT (replace (LINEDESCRIPTOR PREVLINE) of NEXT with PREV)))
          (\TEDIT.CLOSEUPLINES TEXTOBJ PREV NEXT NIL WINDOW) (* And fix up the screen to cover the 
                                                             blank space.)
      ])

(TEDIT.INSERT.DISPLAYTEXT
  [LAMBDA (TEXTOBJ CH CHWIDTH LINE XPOINT DS SEL)            (* ; "Edited 13-Aug-2022 23:37 by rmk")
                                                             (* ; "Edited 30-May-91 16:56 by jds")
                                                             (* This function does the actual 
                                                             displaying of typed-in text on the 
                                                             edit window.)
                                                             (* (PROG ((LOOKS (\TEDIT.APPLY.STYLES
                                                             (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                                             (fetch (TEXTOBJ INSERTPC) of TEXTOBJ) 
                                                             TEXTOBJ)) (TERMSA (fetch
                                                             (TEXTOBJ TXTTERMSA) of TEXTOBJ)) DY 
                                                             FONT) (DSPFONT (SETQ FONT
                                                             (fetch CLFONT of LOOKS)) DS)
                                                             (* Change the font) (COND
                                                             ((IGREATERP (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE))
                                                             (* The font this character is in is 
                                                             taller than the existing line.
                                                             Adjust the LINEDESCRIPTOR's ascent.)
                                                             (\TEDIT.ADJUST.LINES TEXTOBJ LINE DS
                                                             (fetch (LINEDESCRIPTOR YBOT) of
                                                             (fetch (LINEDESCRIPTOR PREVLINE) of 
                                                             LINE)) (IDIFFERENCE (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE)
                                                             (FONTPROP (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)))) (* Move other text 
                                                             to allow for the new height)
                                                             (add (fetch (LINEDESCRIPTOR ASCENT) of 
                                                             LINE) (IDIFFERENCE (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE)))
                                                             (replace (LINEDESCRIPTOR LTRUEASCENT) 
                                                             of LINE with (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT))))) (COND
                                                             ((IGREATERP (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEDESCENT) of LINE))
                                                             (* If the caret's font will change the 
                                                             line's descent, adjust lower lines 
                                                             downward) (\TEDIT.ADJUST.LINES TEXTOBJ
                                                             (fetch (LINEDESCRIPTOR NEXTLINE) of 
                                                             LINE) DS (fetch (LINEDESCRIPTOR YBOT) 
                                                             of LINE) (IDIFFERENCE
                                                             (fetch (LINEDESCRIPTOR LTRUEDESCENT) 
                                                             of LINE) (FONTPROP (fetch CLFONT of 
                                                             LOOKS) (QUOTE DESCENT))))
                                                             (add (fetch (LINEDESCRIPTOR DESCENT) 
                                                             of LINE) (IDIFFERENCE
                                                             (FONTPROP (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEDESCENT) of LINE)))
                                                             (* Fix the line's leading-adjusted 
                                                             descent to account for this change)
                                                             (replace (LINEDESCRIPTOR LTRUEDESCENT) 
                                                             of LINE with (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT))) (* Also the 
                                                             unadjusted descent) (replace
                                                             (LINEDESCRIPTOR YBOT) of LINE with
                                                             (IDIFFERENCE (fetch (LINEDESCRIPTOR 
                                                             YBASE) of LINE) (fetch
                                                             (LINEDESCRIPTOR DESCENT) of LINE)))
                                                             (* And note our new location.)))
                                                             (BITBLT DS XPOINT (fetch
                                                             (LINEDESCRIPTOR YBOT) of LINE) DS
                                                             (IPLUS XPOINT CHWIDTH)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IDIFFERENCE (fetch (LINEDESCRIPTOR 
                                                             RIGHTMARGIN) of LINE) XPOINT)
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE INPUT) (QUOTE REPLACE))
                                                             (* Move the old text over)
                                                             (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             CHWIDTH (fetch (LINEDESCRIPTOR LHEIGHT)
    of LINE) (QUOTE TEXTURE) (QUOTE REPLACE) WHITESHADE) (* Blank out the area we're going to write 
                                                             into) (MOVETO XPOINT
                                                             (IPLUS (fetch (LINEDESCRIPTOR YBASE) 
                                                             of LINE) (OR (fetch CLOFFSET of LOOKS) 
                                                             0)) DS) (* Set the display stream 
                                                             position) (COND (TERMSA
                                                             (* Special terminal table for 
                                                             controlling character display.
                                                             Use it.) (RESETLST (RESETSAVE 
                                                             \PRIMTERMSA TERMSA) (replace
                                                             (TEXTSTREAM REALFILE) of
                                                             (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
    with DS) (COND ((STRINGP CH) (for CHAR instring CH do (SELCHARQ CHAR (TAB (* Put down white)
                                                             (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             36 (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CHAR FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (\DSPPRINTCHAR (fetch
                                                             (TEXTOBJ STREAMHINT) of TEXTOBJ) CHAR))))
                                                             (T (SELCHARQ CH (TAB
                                                             (* Put down white) (BITBLT NIL 0 0 DS 
                                                             XPOINT (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) 36 (fetch (LINEDESCRIPTOR 
                                                             LHEIGHT) of LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CH FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (\DSPPRINTCHAR (fetch
                                                             (TEXTOBJ STREAMHINT) of TEXTOBJ) CH))))))
                                                             (T (* No special handling;
                                                             just use native character codes)
                                                             (COND ((STRINGP CH) (for CHAR instring 
                                                             CH do (SELCHARQ CHAR
                                                             (TAB (* Put down white)
                                                             (BITBLT NIL 0 0 DS (DSPXPOSITION NIL 
                                                             DS) (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) 36 (fetch (LINEDESCRIPTOR 
                                                             LHEIGHT) of LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS
                                                             (DSPXPOSITION NIL DS)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CHAR FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (BLTCHAR CHAR DS))))
                                                             (T (SELCHARQ CH (TAB
                                                             (* Put down white) (BITBLT NIL 0 0 DS
                                                             (DSPXPOSITION NIL DS)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             36 (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (* Blank out the CR's width.)
                                                             (BITBLT NIL 0 0 DS (DSPXPOSITION NIL 
                                                             DS) (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) (IMAX 6 (CHARWIDTH CH FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (BLTCHAR CH DS))))))
                                                             (BITBLT NIL 0 0 DS (fetch
                                                             (LINEDESCRIPTOR LXLIM) of LINE)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (* Clear after EOL) (TEDIT.MODIFYLOOKS 
                                                             LINE XPOINT DS LOOKS
                                                             (fetch (LINEDESCRIPTOR YBASE) of LINE))
                                                             (* Do underlining, strike-out, etc.)))
    (HELP])

(TEDIT.INSERT.UPDATESCREEN
  [LAMBDA (CH CH# CHARS XPOINT TEXTOBJ SEL OTEXTLEN BLANKSEEN CRSEEN DONTSCROLL INCREMENTAL)
                                                             (* ; "Edited 12-Aug-2022 18:04 by rmk")
                                                             (* ; "Edited 30-May-91 16:06 by jds")
                                                             (* ; 
                                                          "Update the edit window after an insertion")
    (PROG ((THISLINE (fetch (TEXTOBJ THISLINE) of TEXTOBJ))
           (WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ))
           SELINE)
          (replace (SELECTION CH#) of SEL with (IPLUS CHARS CH#))
                                                             (* ; 
                                    "These must be here, since SELs are valid even without a window.")
          (replace (SELECTION CHLIM) of SEL with (fetch (SELECTION CH#) of SEL))
          (replace (SELECTION POINT) of SEL with 'LEFT)
          (replace (SELECTION DCH) of SEL with 0)
          (replace (SELECTION SELKIND) of SEL with 'CHAR)
          (COND
             ((AND INCREMENTAL (\SYSBUFP))

              (* ;; "We're doing incremental updates, and there's type-in waiting.  Bail out, now that we have fixed up the selection.")

              (RETURN))
             ((fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)    (* ; 
                                            "Don't update the screen if updates are being inhibited.")
              (RETURN))
             ((NOT WINDOW)                                   (* ; 
                                              "If this textobj has no window to update, don't bother")
              (RETURN))
             ((OR T (LISTP WINDOW)
                  (TEXTPROP TEXTOBJ 'SLOWUPDATE))            (* ; 
                                                     "FOR NOW, ALWAYS UPDATE THE SCREEN THE HARD WAY")
              (TEDIT.UPDATE.SCREEN TEXTOBJ NIL T (fetch (SELECTION CH#) of SEL))
              (\FIXSEL SEL TEXTOBJ)
              (\SHOWSEL SEL NIL T)))
          (\COPYSEL SEL TEDIT.SELECTION)
          [for WW inside WINDOW as L1 inside (fetch (SELECTION L1) of SEL) as LN
             inside (fetch (SELECTION LN) of SEL) as L1LIST on (fetch (SELECTION L1) of SEL)
             as LNLIST on (fetch (SELECTION LN) of SEL)
             do (COND
                   (DONTSCROLL 

                          (* ;; "If scrolling is suppressed, don't bother with the next check:")

                          (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ WW))
                   [(EQ WW (fetch (TEXTOBJ SELWINDOW) of TEXTOBJ))
                    (COND
                       ([OR (NULL (SELECTQ (fetch (SELECTION POINT) of SEL)
                                      (LEFT L1)
                                      (RIGHT LN)
                                      NIL))
                            (ILEQ (SELECTQ (fetch (SELECTION POINT) of SEL)
                                      (LEFT (fetch (LINEDESCRIPTOR YBOT) of L1))
                                      (RIGHT (fetch (LINEDESCRIPTOR YBOT) of LN))
                                      0)
                                  (fetch (REGION BOTTOM) of (DSPCLIPPINGREGION NIL WW]

                        (* ;; 
    "The caret is off-window in the selection window.  Need to scroll it up so the caret is visible.")

                        (while (OR [COND
                                      ((SETQ SELINE (SELECTQ (fetch (SELECTION POINT) of SEL)
                                                        (LEFT (CAR L1LIST))
                                                        (RIGHT (CAR LNLIST))
                                                        NIL))
                                       (ILESSP (fetch (LINEDESCRIPTOR YBOT) of SELINE)
                                              (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                                      (T (ILESSP (fetch (SELECTION Y0) of SEL)
                                                (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ]
                                   (AND (IGEQ (fetch (SELECTION Y0) of SEL)
                                              (fetch (TEXTOBJ WTOP) of TEXTOBJ))
                                        (NULL SELINE)))
                           do 
                              (* ;; "The caret just went off-screen.  Move it up some.")

                              (replace (TEXTOBJ EDITOPACTIVE) of TEXTOBJ with NIL)
                              (SCROLLW WW 0 (LLSH (COND
                                                     [(SELECTQ (fetch (SELECTION POINT) of SEL)
                                                          (LEFT (CAR L1LIST))
                                                          (RIGHT (CAR LNLIST))
                                                          NIL)
                                                      (fetch (LINEDESCRIPTOR LHEIGHT)
                                                         of (SELECTQ (fetch (SELECTION POINT)
                                                                        of SEL)
                                                                (LEFT (CAR L1LIST))
                                                                (RIGHT (CAR LNLIST))
                                                                (SHOULDNT]
                                                     (T 12))
                                                  1]
                   (T (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ WW]
          (\COPYSEL SEL TEDIT.SELECTION])

(TEDIT.UPDATE.SCREEN
  [LAMBDA (TEXTOBJ STARTINGLINE INCREMENTAL? NEXTCARETCH#)   (* ; "Edited 30-May-91 15:58 by jds")
                                                             (* Update the screen, as needed to fix 
                                                             up "dirty" lines.)
    (SETQ TEXTOBJ (TEXTOBJ TEXTOBJ))
    (COND
       ((NOT (fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ))    (* ; 
                                          "Only update the screen if we aren't suppressing updating.")
        (bind NLINE for WW inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) as LINE
           inside (OR STARTINGLINE (fetch (TEXTOBJ LINES) of TEXTOBJ))
           do (SETQ NLINE (\TEDIT.FIXCHANGEDPART TEXTOBJ LINE WW INCREMENTAL? NEXTCARETCH#)) 
                                                             (* The last line in the edit window)
              (AND NLINE (\FILLWINDOW (fetch (LINEDESCRIPTOR YBOT) of NLINE)
                                NLINE TEXTOBJ NIL WW NEXTCARETCH#])

(\BACKFORMAT
  [LAMBDA (LINES TEXTOBJ WHEIGHT)                            (* ; "Edited  8-Sep-2022 16:41 by rmk")
                                                             (* ; "Edited 30-May-91 15:58 by jds")

    (* ;; "Move back to the next preceding EOL (to guarantee a line break), then format lines to reach where we are now.")

    (* ;; "LINES is the dummy first line for this window in TEXTOBJ")

    (* ;; "Returns a pointer to the last of the back-formatted lines (i.e., the one that comes latest in the document), or to LINES if no lines are formatted")

    (PROG ((LINE1 (fetch (LINEDESCRIPTOR NEXTLINE) of LINES))
           CH1 CHNO LINE)
          (SETQ CH1 (CL:IF LINE1
                        (fetch (LINEDESCRIPTOR CHAR1) of LINE1)
                        (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
          (CL:WHEN (ILEQ CH1 1)                              (* ; 
                                                 "No more lines to format--at the front of the file.")
              (RETURN LINES))                                (* ; "More to do.")
          [SETQ CHNO (find I (TSTREAM _ (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                        from (IDIFFERENCE CH1 2) to 2 by -1 first (\TEXTSETFILEPTR TSTREAM
                                                                         (IDIFFERENCE CH1 2)) 
                                                             (* ; 
                                                      "Because fileptrs are one back from characters")
                        suchthat (EQ (CHARCODE EOL)
                                     (\BACKBIN TSTREAM]
          (CL:UNLESS CHNO                                    (* ; 
                                                   "But never further than the front of the document")
              (SETQ CHNO 1))
          (while (ILEQ CHNO (SUB1 CH1)) do                   (* ; 
                           "Now move forward, formatting lines until we catch up with where we were.")
                                           (SETQ LINE (\FORMATLINE TEXTOBJ NIL CHNO)) 
                                                             (* ; "Format the next line")
                                           (replace (LINEDESCRIPTOR YBOT) of LINE with WHEIGHT) 
                                                             (* ; 
                                                             "Make sure it thinks it's off-window")
                                           (replace (LINEDESCRIPTOR YBASE) of LINE with WHEIGHT)
                                           (replace (LINEDESCRIPTOR PREVLINE) of LINE with LINES) 
                                                             (* ; "Hook it onto the end of the chain")
                                           (replace (LINEDESCRIPTOR NEXTLINE) of LINES with LINE)
                                           (SETQ LINES LINE)
                                           (SETQ CHNO (ADD1 (fetch (LINEDESCRIPTOR CHARLIM)
                                                               of LINE))) 
                                                             (* ; 
                                                             "And find the start of the next line"))
          (replace (LINEDESCRIPTOR NEXTLINE) of LINE with LINE1)
                                                             (* ; 
                    "Now, with the final line we formatted, hook the rest of the line chain onto it.")
          (AND LINE1 (replace (LINEDESCRIPTOR PREVLINE) of LINE1 with LINE))
          (RETURN LINE])

(\FILLWINDOW
  [LAMBDA (YBOT CURLINE TEXTOBJ DONTFILLFLG WINDOW NEXTCARETCH#)
                                                             (* ; "Edited  9-Sep-2022 21:22 by rmk")
                                                             (* ; "Edited  6-Sep-2022 11:12 by rmk")
                                                             (* ; "Edited 30-May-91 16:57 by jds")

    (* ;; "Fill out TEXTOBJ's window, starting with the line after CURLINE, whose ybottom is YBOT")

    (* ;; "Return T if any lines are moved up.")

    (* ;; "DONTFILLFLG => Don't bother printing any new lines at the bottom of the screen.")

    (* ;; "NEXTCARETCH# => always format to at least this CH#, to assure that we know where the caret will next be.")

    (CL:UNLESS WINDOW
        (SETQ WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)))
    (LET ((LINE (fetch (LINEDESCRIPTOR NEXTLINE) of CURLINE))
          (CHARLIM (fetch (LINEDESCRIPTOR CHARLIM) of CURLINE))
          (PREVLINE CURLINE)
          (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
          (LINES\DELETED NIL)
          (WHEIGHT (WINDOWPROP WINDOW 'HEIGHT))
          NEXTLINE OFLOWFN)
         (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
         (while (AND LINE (IGEQ (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                WHEIGHT)) do                 (* ; 
                                     "Do not start with a line which is above the top of the screen.")
                                             (SETQ PREVLINE LINE)
                                             (SETQ CHARLIM (fetch (LINEDESCRIPTOR CHARLIM)
                                                              of LINE))
                                             (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)))
         [repeatwhile (ILESSP CHARLIM TEXTLEN)
            do                                               (* ; 
                                                       "Walk thru the lines below the starting line.")
               [COND
                  ((AND LINE (IGEQ (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM YBOT LINE PREVLINE))
                                   (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                                                             (* ; 
                                  "If there is a line to display, and space to display it, go ahead.")
                   (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                   (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                    DESCENT)
                                                                               of LINE)))
                   (\DISPLAYLINE TEXTOBJ LINE WINDOW))
                  [(AND LINE NEXTCARETCH# (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                                NEXTCARETCH#))
                                                             (* ; 
                        "There's a line, and it's earlier than the next caret location.  Keep going.")
                   (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                   (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                    DESCENT)
                                                                               of LINE]
                  (LINE                                      (* ; 
                                                             "There is a line, but it won't fit.")
                        [SETQ YBOT (COND
                                      ((fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                                  of LINE))
                                       (fetch (LINEDESCRIPTOR YBOT) of PREVLINE))
                                      (T (IPLUS YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE]
                                                             (* ; 
    "This existing line won't fit.  Punt out of this, setting YBOT so the screen gets cleared right.")
                        (CL:WHEN (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                                             (* ; 
                            "Try calling any user-supplied overflow fn, to handle the space overflow")
                            (CL:WHEN (APPLY* OFLOWFN WINDOW TEXTOBJ)
                                (RETFROM '\FILLWINDOW NIL)))
                        (RETURN))
                  (DONTFILLFLG                               (* ; 
                                      "We are instructed NOT to try filling the screen, so punt out.")
                         (RETURN))
                  ((OR (ILESSP CHARLIM TEXTLEN)
                       (AND (IEQP CHARLIM TEXTLEN)
                            (fetch (LINEDESCRIPTOR CR\END) of CURLINE))
                       (ZEROP TEXTLEN))

                   (* ;; "No existing lines to display, but there's text left (or the doc is empty and we need a dummy first line)")

                   (SETQ LINE (\FORMATLINE TEXTOBJ NIL (ADD1 CHARLIM)))
                                                             (* ; "Format the next line")
                   (replace (LINEDESCRIPTOR PREVLINE) of LINE with PREVLINE)
                                                             (* ; 
                                                         "Hook it into the chain of line descriptors")
                   (replace (LINEDESCRIPTOR NEXTLINE) of LINE with (SETQ NEXTLINE (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                          NEXTLINE)
                                                                                     of PREVLINE)))
                   (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with LINE)
                   (CL:WHEN NEXTLINE
                       (replace (LINEDESCRIPTOR PREVLINE) of NEXTLINE with LINE))
                   [SETQ YBOT (COND
                                 [(fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                             of LINE))
                                  (IDIFFERENCE (IPLUS YBOT (fetch (LINEDESCRIPTOR DESCENT)
                                                              of PREVLINE))
                                         (IPLUS (fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR 
                                                                                      LFMTSPEC)
                                                                           of LINE))
                                                (fetch (LINEDESCRIPTOR DESCENT) of LINE]
                                 (T (IDIFFERENCE YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE]
                   (COND
                      ((IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                                             "If there's room, display the new line")
                       (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                       (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                        DESCENT)
                                                                                   of LINE)))
                       (\DISPLAYLINE TEXTOBJ LINE WINDOW))
                      [(AND NEXTCARETCH# (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                               NEXTCARETCH#))(* ; 
           "This line is needed to find the next caret location, even tho it won't fit on the screen")
                       (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                       (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                        DESCENT)
                                                                                   of LINE]
                      (T                                     (* ; 
                                                        "Otherwise, we've overflown the window again")
                         (SETQ YBOT (IPLUS YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)))
                         (CL:WHEN (AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                       (APPLY* OFLOWFN WINDOW TEXTOBJ))
                             (RETFROM '\FILLWINDOW NIL))
                         (RETURN]
               (COND
                  (LINE                                      (* ; 
                                                 "Move forward to the next line in the chain, if any")
                        (SETQ CHARLIM (fetch (LINEDESCRIPTOR CHARLIM) of LINE))
                        (SETQ PREVLINE LINE)
                        (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)))
                  (T                                         (* ; 
                                               "Otherwise, note that we ran off the end of the file.")
                     (SETQ CHARLIM (ADD1 TEXTLEN]
         (while LINE do                                      (* ; 
          "If there are any existing lines which didn't fit, set their YBOTs to 0 so they don't show")
                        (CL:WHEN (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                       TEXTLEN)
                            (replace (LINEDESCRIPTOR YBOT) of LINE with (SUB1 (fetch (TEXTOBJ WBOTTOM
                                                                                            )
                                                                                 of TEXTOBJ))))
                        (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)))
         (CL:WHEN (IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                  "If there is space left at the bottom of the window, blank it out.")
             (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                    (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                    (IDIFFERENCE YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                    'TEXTURE
                    'REPLACE WHITESHADE))
         (CL:WHEN (AND PREVLINE (fetch (LINEDESCRIPTOR CR\END) of PREVLINE)
                       (OR (ILESSP (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                                  WHEIGHT)
                           (ILEQ (fetch (LINEDESCRIPTOR CHARTOP) of PREVLINE)
                                 0))
                       (IGEQ (fetch (LINEDESCRIPTOR CHARLIM) of PREVLINE)
                             TEXTLEN))                       (* ; 
                                          "If the last line ends in a CR, put a dummy line below it.")
             [SETQ LINE (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with (\FORMATLINE TEXTOBJ NIL
                                                                                   (ADD1 TEXTLEN]
             (replace (LINEDESCRIPTOR PREVLINE) of LINE with PREVLINE)
             (replace (LINEDESCRIPTOR YBOT) of LINE with (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT)
                                                                         of PREVLINE)
                                                                (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                   of LINE)))
             (replace (LINEDESCRIPTOR YBASE) of LINE with (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT)
                                                                          of PREVLINE)
                                                                 (fetch (LINEDESCRIPTOR ASCENT)
                                                                    of LINE)))
             (replace (LINEDESCRIPTOR CHARLIM) of LINE with (ADD1 TEXTLEN))
             (SETQ PREVLINE LINE))
         (CL:WHEN (AND (IGEQ (fetch (LINEDESCRIPTOR CHARLIM) of PREVLINE)
                             TEXTLEN)
                       (NOT (fetch (LINEDESCRIPTOR CR\END) of PREVLINE)))
                                                             (* ; 
                                    "This line lies at end of text, so chop off any following lines.")
             (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with NIL))
         LINES\DELETED])

(\FIXDLINES
  [LAMBDA (LINES SEL CH#1 CH#LIM TEXTOBJ)                    (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; 
    "Fix up the list LINES of line descriptors, given that characters CH#1 thru CH#LIM were deleted.")

    (* ;; "Change CHAR1 and CHARLIM entries in each descriptor, and remove any descriptors for lines which disappeared entirely.")

    (COND
       ((NOT (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ))

        (* ;; "Only do this if we're allowed to change the document.")

        (for WW inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
           do (SETQ LINES (WINDOWPROP WW 'LINES))
              (PROG ((NLINES LINES)
                     (DCH (IDIFFERENCE CH#LIM CH#1))
                     (CH#1L (SUB1 CH#1))
                     PL NL CHARLIM)
                    (bind (LINE _ (fetch (LINEDESCRIPTOR NEXTLINE) of LINES))
                          CHARLIM CHAR1 while LINE
                       do (SETQ CHARLIM (fetch (LINEDESCRIPTOR CHARLIM) of LINE))
                          (SETQ CHAR1 (fetch (LINEDESCRIPTOR CHAR1) of LINE))
                          (COND
                             [(ILESSP CHARLIM CH#1)
                              (COND
                                 ((AND (IGEQ CH#1 CHAR1)
                                       (ILEQ CH#1 (fetch (LINEDESCRIPTOR CHARTOP) of LINE)))

                                  (* ;; "This change happened in a place where it may affect this line's break decision.  Better reformat to be safe.")

                                  (replace (LINEDESCRIPTOR DIRTY) of LINE with T)
                                  (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T))
                                 ((AND (fetch (LINEDESCRIPTOR CR\END) of LINE)
                                       (IEQP CHARLIM CH#1L))

                                  (* ;; "This line ends in CR, and the deletion starts immediately thereafter.  Best to reformat, for safety.")

                                  (replace (LINEDESCRIPTOR DIRTY) of LINE with T)
                                  (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T]
                             ((IGEQ CHAR1 CH#LIM)            (* ; 
    "This line contains none of the deleted text but is after it.  Update CHAR1, CHARLIM and CHARTOP")
                              (replace (LINEDESCRIPTOR CHAR1) of LINE with (IMAX 1 (IDIFFERENCE
                                                                                    CHAR1 DCH)))
                              (replace (LINEDESCRIPTOR CHARLIM) of LINE with (IDIFFERENCE CHARLIM DCH
                                                                                    ))
                              (replace (LINEDESCRIPTOR CHARTOP) of LINE
                                 with (IDIFFERENCE (fetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                             DCH)))
                             [(OR (ILESSP CHAR1 CH#1)
                                  (IGEQ CHARLIM CH#LIM))     (* ; 
         "This line contains some of the deleted text, mark it as dirty and update CHAR1 and CHARLIM")
                              (replace (LINEDESCRIPTOR DIRTY) of LINE with T)
                              (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)
                              (replace (LINEDESCRIPTOR CHAR1) of LINE with (IMAX 1 (IMIN CHAR1 CH#1))
                                     )
                              (COND
                                 [(IGEQ CHARLIM CH#LIM)
                                  (replace (LINEDESCRIPTOR CHARLIM) of LINE
                                     with (IDIFFERENCE CHARLIM (IMIN DCH (IDIFFERENCE CH#LIM CHAR1]
                                 (T (replace (LINEDESCRIPTOR CHARLIM) of LINE with CH#1L]
                             (T                              (* ; 
                                            "This line is totally within the deleted text, remove it")
                                (SETQ NL (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                                (SETQ PL (fetch (LINEDESCRIPTOR PREVLINE) of LINE))
                                (COND
                                   (PL (replace (LINEDESCRIPTOR NEXTLINE) of PL with NL)))
                                (COND
                                   (NL (replace (LINEDESCRIPTOR PREVLINE) of NL with PL)))
                                (COND
                                   ((EQ NLINES LINE)
                                    (SETQ NLINES NL)))
                                (replace (LINEDESCRIPTOR DELETED) of LINE with T)
                                                             (* ; 
                                      "Mark this line deleted, so DELETETEXTCHARS know to ignore it.")
                                (AND NL (replace (LINEDESCRIPTOR DIRTY) of NL with T))
                                                             (* ; 
                  "This may well force a reformatting of the next line.  Mark it dirty just in case.")
                                ))
                          (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)))
                    (\TEDIT.FIXDELSEL (fetch (TEXTOBJ SEL) of TEXTOBJ)
                           TEXTOBJ CH#1 CH#LIM DCH)          (* ; 
                                                             "Fix up the selections in this textobj")
                    (\TEDIT.FIXDELSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                           TEXTOBJ CH#1 CH#LIM DCH)
                    (\TEDIT.FIXDELSEL (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                           TEXTOBJ CH#1 CH#LIM DCH)
                    (\TEDIT.FIXDELSEL (fetch (TEXTOBJ DELETESEL) of TEXTOBJ)
                           TEXTOBJ CH#1 CH#LIM DCH)
                    (RETURN NLINES])

(\FIXILINES
  [LAMBDA (TEXTOBJ SEL CH#1 DCH OTEXTLEN)                    (* ; "Edited 30-May-91 16:07 by jds")

    (* ;; "Fix the list LINES of line descriptors to account for DCH characters inserted before CH#1")

    (COND
       ((NOT (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ))

        (* ;; "Only make this change if you're allowed to change the document.")

        (LET (LINES CH# CHLIM CHAR1 CHARLIM)
             (SETQ CH#1 (IMAX CH#1 1))                       (* ; 
                                                         "Make sure we're inserting in a legit spot.")
             [for WW inside (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ) as LINES
                inside (fetch (TEXTOBJ LINES) of TEXTOBJ) as L1 in (fetch (SELECTION L1) of SEL)
                do 
                   (* ;; "For each pane in the editing window, examine the pane's list of lines")

                   (bind [LINE _ (COND
                                    ((IGEQ (ffetch (LINEDESCRIPTOR CHARTOP) of LINES)
                                           0)                (* ; 
                                                           "Make sure to skip the initial dummy line")
                                     LINES)
                                    (T (ffetch (LINEDESCRIPTOR NEXTLINE) of LINES] while LINE
                      do (\DTEST LINE 'LINEDESCRIPTOR)
                         (COND
                            ((IGREATERP (SETQ CHAR1 (ffetch (LINEDESCRIPTOR CHAR1) of LINE))
                                    CH#1)                    (* ; 
                                     "This line starts after the insertion point.  Update it's CHAR1")
                             (freplace (LINEDESCRIPTOR CHAR1) of LINE with (IPLUS CHAR1 DCH)))
                            ((AND (IEQP CH#1 CHAR1)
                                  (NEQ LINE L1))             (* ; 
                   "The insertion is at the end of the PRIOR line--so go ahead and update this CHAR1")
                             (freplace (LINEDESCRIPTOR CHAR1) of LINE with (IPLUS CHAR1 DCH))
                             (COND
                                ((ffetch (LINEDESCRIPTOR PREVLINE) of LINE)
                                 (freplace (LINEDESCRIPTOR DIRTY) of (ffetch (LINEDESCRIPTOR PREVLINE
                                                                                    ) of LINE)
                                    with T)))
                             (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                             (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T))
                            ((IGEQ (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                   CH#1)                     (* ; 
                                                  "This line spans the insert point.  Mark it DIRTY.")
                             (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                             (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T))
                            ((AND (IGEQ (SETQ CHARLIM (ffetch (LINEDESCRIPTOR CHARLIM) of LINE))
                                        OTEXTLEN)
                                  (NOT (ffetch (LINEDESCRIPTOR CR\END) of LINE)))

                             (* ;; "This line is the last in the file, and its CHAR1 is <= the insert point, and it doesn't end in a CR.  Therefore, move the line's end upward to accomodate the insertion.")

                             (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                             (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)))
                         [COND
                            ([OR (IGEQ (SETQ CHARLIM (ffetch (LINEDESCRIPTOR CHARLIM) of LINE))
                                       CH#1)
                                 (AND (IGEQ CHARLIM OTEXTLEN)
                                      (NOT (ffetch (LINEDESCRIPTOR CR\END) of LINE]
                             (freplace (LINEDESCRIPTOR CHARLIM) of LINE with (IPLUS CHARLIM DCH))
                             (COND
                                ((IGEQ (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                       CH#1)
                                 (freplace (LINEDESCRIPTOR CHARTOP) of LINE
                                    with (IPLUS (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                                DCH]
                         (SETQ LINE (ffetch (LINEDESCRIPTOR NEXTLINE) of LINE]
             (\TEDIT.FIXINSSEL (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                    TEXTOBJ CH#1 DCH)
             (\TEDIT.FIXINSSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                    TEXTOBJ CH#1 DCH)
             (\TEDIT.FIXINSSEL SEL TEXTOBJ CH#1 DCH])

(\SHOWTEXT
  [LAMBDA (TEXTOBJ WINDOW)

    (* ;; "Edited  6-Sep-2022 11:06 by rmk")

    (* ;; "Edited 12-Jan-2022 18:56 by rmk: I took out the WAITINGCURSOR, the resetsave wasn't working for some reason, and it really isn't necessary for modern machines.")

    (* ;; "Edited 12-Jun-90 19:22 by mitani")

    (* ;; "Fill the editor window with text, starting from the top of the file.")

    (CL:WHEN (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)            (* ; 
                                                           "If there is no edit window, just return.")
        (LET (WREG LINES)
             (SETQ WINDOW (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ)))
             (DSPFILL (PROG1 (DSPCLIPPINGREGION NIL WINDOW)  (* ; "For region within a window:")
                             )
                    WHITESHADE
                    'REPLACE WINDOW)                         (* ; "Clear the window.")
             (RESETLST

                 (* ;; "RMK: For reasons unknown, the original cursor is not restored when this exits.  But there is presumably no need for this waiting indicator in modern times.  This only fills lines visible within a window, and machines are really fast.")

                 (* ;; "Display the hourglass cursor as we work")

                 (AND NIL (RESETSAVE (CURSOR WAITINGCURSOR)))

                 (* ;; "Make sure we have the anchor pseudo-line")

                 (SETQ LINES
                  (create LINEDESCRIPTOR
                         YBOT _ (WINDOWPROP WINDOW 'HEIGHT)
                         CHAR1 _ 0
                         CHARLIM _ 0
                         SPACELEFT _ -1
                         RIGHTMARGIN _ (SUB1 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ))
                         NEXTLINE _ NIL
                         CHARTOP _ -1
                         LHEIGHT _ 0
                         LXLIM _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                         CR\END _ T
                         ASCENT _ 0
                         DESCENT _ 0
                         LTRUEASCENT _ 0
                         LFMTSPEC _ TEDIT.DEFAULT.FMTSPEC))
                 (WINDOWPROP WINDOW 'LINES LINES)            (* ; "Fill the window as usual")
                 (\FILLWINDOW (WINDOWPROP WINDOW 'HEIGHT)
                        LINES TEXTOBJ NIL WINDOW)
                 (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ WINDOW)
                 LINES)))])

(\TEDIT.ADJUST.LINES
  [LAMBDA (TEXTOBJ FIRSTLINE WINDOW LINETOP DY)              (* ; "Edited 30-May-91 15:59 by jds")

         (* Move all lines from FIRSTLINE (inclusive) on up or down.
         Fill in a line or drop one off, accordingly.
         Positive DY means move UP.)

         (* LINETOP is the top of the region to be moved as the adjustment is made.
         It corresponds to the TOP of FIRSTLINE.)

    (PROG ((OFLOW NIL)
           OFLOWFN OYBOT PREVLINE)
          [COND
             ((ZEROP DY)                                     (* This line's total height HAS NOT 
                                                             CHANGED. Don't make any adjustments.)
              )
             ((ILESSP LINETOP (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* This line is off the screen.
                                                             Don't bother adjusting it.)
              )
             (FIRSTLINE 

         (* This line's total height changed -- must move the rest of the window, and 
         adjust YBOT/BASEs.)

                    (bind (LL _ FIRSTLINE) while (AND LL (IGEQ (fetch (LINEDESCRIPTOR YBOT)
                                                                  of LL)
                                                               (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                       do 

         (* Loop thru the line descriptors that are affected by the change
         (i.e., those below it)%, and adjust their Y locations.)

                          (SETQ OYBOT (fetch (LINEDESCRIPTOR YBOT) of LL))
                          [COND
                             ((ILESSP (replace (LINEDESCRIPTOR YBOT) of LL with (IPLUS OYBOT DY))
                                     (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* This line moved below the bottom of 
                                                             the screen)
                              (BITBLT NIL 0 0 WINDOW 0 OYBOT (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                     (fetch (LINEDESCRIPTOR LHEIGHT) of LL)
                                     'TEXTURE
                                     'REPLACE WHITESHADE)    (* So clear the space it used to 
                                                             occupy.)
                              (COND
                                 ((AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                       (SETQ OFLOW T)
                                       (APPLY* OFLOWFN WINDOW TEXTOBJ)
                                       (RETURN NIL))

         (* We walked off the bottom, and the user gave us an OFLOWFN to handle it.
         Give it a try.)

                                  ]
                          (add (fetch (LINEDESCRIPTOR YBASE) of LL)
                               DY)                           (* Adjust the baseline of the line, as 
                                                             well as its physical bottom.)
                          (replace (LINEDESCRIPTOR YBOT) of LL with (IDIFFERENCE (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                         YBASE)
                                                                                    of LL)
                                                                           (fetch (LINEDESCRIPTOR
                                                                                   DESCENT)
                                                                              of LL))) 
                                                             (* I realize this looks redundant, but 
                                                             the line's descent may have changed, 
                                                             too.)
                          (SETQ PREVLINE LL) 

         (* Remember the prior line, since we'll need it if we later try to fill out the 
         window with more text.)

                          (SETQ LL (fetch (LINEDESCRIPTOR NEXTLINE) of LL)) 
                                                             (* Move to the next line.))
                    (AND OFLOW (RETURN NIL))

         (* If there was an overflow, and it got handled by the user's OFLOWFN, don't 
         bother trying anything further.)

                    (COND
                       [(IGREATERP DY 0)                     (* The line is shorter;
                                                             move the rest up.)
                        (BITBLT WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                               WINDOW 0 (IPLUS DY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                               (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                               LINETOP
                               'INPUT
                               'REPLACE)                     (* Move the text up)
                        (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                               (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                               DY
                               'TEXTURE
                               'REPLACE WHITESHADE)          (* Now clear the bottom part of the 
                                                             window, which got vacated by the 
                                                             adjustment)
                        (COND
                           ((AND PREVLINE (IGEQ (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                                                (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))

         (* If there is space left on the screen, try to fill it with new text.)

                            (\FILLWINDOW (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                                   PREVLINE TEXTOBJ NIL WINDOW]
                       (T                                    (* The line is taller;
                                                             move the rest down.)
                          (BITBLT WINDOW 0 (IPLUS (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                                  (IMINUS DY))
                                 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                 (IDIFFERENCE LINETOP (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                 'INPUT
                                 'REPLACE)                   (* Move the text down)
                          (BITBLT NIL 0 0 WINDOW 0 (IPLUS LINETOP DY)
                                 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                 (IMINUS DY)
                                 'TEXTURE
                                 'REPLACE WHITESHADE)        (* Now clear the region we moved it 
                                                             out of.)
                          ]
          (RETURN T])

(\TEDIT.CLEAR.SCREEN.BELOW.LINE
  [LAMBDA (TEXTOBJ WINDOW LINE)                              (* ; "Edited 30-May-91 15:59 by jds")
                                                             (* Clears the edit window to white, 
                                                             clearing only the sapce below the line 
                                                             given.)
    (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
           (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
           (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of LINE)
                  (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
           'TEXTURE
           'REPLACE WHITESHADE])

(\TEDIT.CLOSEUPLINES
  [LAMBDA (TEXTOBJ PREVLINE NEXTLINE DONTFILLFLG WINDOW)     (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; "Given a gap between PREVLINE and NEXTLINE, move NEXTLINE et seq up to coverthe gap, and adjust the YBOTs.  If DONTFILLFLG is T then we're not filling the screen")
                                                             (* ; 
                                                          "NEXTLINE = NIL => remove all lower lines.")
    (COND
       (PREVLINE                                             (* ; 
                                                         "PREVLINE = NIL => DON'T close up anything.")
              (PROG [DY (WWIDTH (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                       (fetch (TEXTOBJ WLEFT) of TEXTOBJ)))
                        (LOWESTY (COND
                                    (PREVLINE (fetch (LINEDESCRIPTOR YBOT) of PREVLINE))
                                    (T (ADD1 (fetch (TEXTOBJ WTOP) of TEXTOBJ]
                    [COND
                       (NEXTLINE                             (* ; 
                                        "If the gap isn't at the end, move whatever else up over it.")
                              [SETQ DY (IDIFFERENCE LOWESTY (IPLUS (fetch (LINEDESCRIPTOR YBOT)
                                                                      of NEXTLINE)
                                                                   (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                      of NEXTLINE]
                              (AND (ILEQ DY 0)
                                   (RETURN))                 (* ; 
                                                "If there's no gap, don't bother with anything else.")
                              (BITBLT WINDOW (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                     (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                     WINDOW
                                     (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                     (IPLUS DY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                     WWIDTH
                                     (IPLUS (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of NEXTLINE)
                                                   (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                            (fetch (LINEDESCRIPTOR LHEIGHT) of NEXTLINE))
                                     'INPUT
                                     'REPLACE)               (* ; "Move the remaining lines upward.")
                              (bind (LINE _ NEXTLINE)
                                    (NYBOT _ LOWESTY) while LINE
                                 do                          (* ; 
                               "Scan the remaining lines, fixing up the vertical spacing information")
                                    (SETQ NYBOT (IDIFFERENCE NYBOT (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                      of LINE)))
                                    (COND
                                       ((IGEQ NYBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                        (SETQ LOWESTY NYBOT)))
                                    [COND
                                       [(ILESSP (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                               (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                                 "Line is off screen.  Display it at the right spot.")
                                        (AND DONTFILLFLG (RETURN))
                                                             (* ; 
                                                   "If we're not filling the screen, then stop here.")
                                        (replace (LINEDESCRIPTOR YBOT) of LINE with NYBOT)
                                        (replace (LINEDESCRIPTOR YBASE) of LINE
                                           with (IPLUS NYBOT (fetch (LINEDESCRIPTOR DESCENT)
                                                                of LINE)))
                                        (\DISPLAYLINE TEXTOBJ LINE WINDOW)
                                        (COND
                                           ((fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
                                                             (* ; 
                                                 "There's a next line after the current one.  Use it")
                                            )
                                           ((IGEQ (fetch (LINEDESCRIPTOR CHARLIM) of LINE)
                                                  (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                                                             (* ; 
                               "We're at the end of the text;  don't bother trying to add more lines")
                                            )
                                           (T                (* ; 
                                                            "There's more;  try adding another line.")
                                              [replace (LINEDESCRIPTOR NEXTLINE) of LINE
                                                 with (\FORMATLINE TEXTOBJ NIL
                                                             (ADD1 (fetch (LINEDESCRIPTOR CHARLIM)
                                                                      of LINE]
                                              (replace (LINEDESCRIPTOR PREVLINE)
                                                 of (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
                                                 with LINE]
                                       (T                    (* ; 
                                                           "Line is visible;  just update YBOT/YBASE")
                                          (replace (LINEDESCRIPTOR YBOT) of LINE with NYBOT)
                                          (replace (LINEDESCRIPTOR YBASE) of LINE
                                             with (IPLUS (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                         (fetch (LINEDESCRIPTOR DESCENT) of LINE]
                                    (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                                 until (ILESSP NYBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ]
                    (BITBLT NIL 0 0 WINDOW (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                           (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                           WWIDTH
                           (IDIFFERENCE LOWESTY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                           'TEXTURE
                           'REPLACE WHITESHADE)              (* ; 
                                   "Clear the part of the screen below the lowest line now displayed")
                    (RETURN T])

(\TEDIT.COPY.LINEDESCRIPTOR
  [LAMBDA (FROMLINE TOLINE)                                  (* ; "Edited 30-May-91 16:57 by jds")

         (* Copy the contents of one line descriptor into another --
         except for chaining and Y-location info.)

    (freplace (LINEDESCRIPTOR LEFTMARGIN) of TOLINE with (ffetch (LINEDESCRIPTOR LEFTMARGIN)
                                                            of FROMLINE))
    (freplace (LINEDESCRIPTOR RIGHTMARGIN) of TOLINE with (ffetch (LINEDESCRIPTOR RIGHTMARGIN)
                                                             of FROMLINE))
    (freplace (LINEDESCRIPTOR LXLIM) of TOLINE with (ffetch (LINEDESCRIPTOR LXLIM) of FROMLINE))
    (freplace (LINEDESCRIPTOR SPACELEFT) of TOLINE with (ffetch (LINEDESCRIPTOR SPACELEFT)
                                                           of FROMLINE))
    (freplace (LINEDESCRIPTOR LHEIGHT) of TOLINE with (ffetch (LINEDESCRIPTOR LHEIGHT) of FROMLINE))
    (freplace (LINEDESCRIPTOR CHAR1) of TOLINE with (ffetch (LINEDESCRIPTOR CHAR1) of FROMLINE))
    (freplace (LINEDESCRIPTOR CHARLIM) of TOLINE with (ffetch (LINEDESCRIPTOR CHARLIM) of FROMLINE))
    (freplace (LINEDESCRIPTOR CHARTOP) of TOLINE with (ffetch (LINEDESCRIPTOR CHARTOP) of FROMLINE))
    (freplace (LINEDESCRIPTOR DIRTY) of TOLINE with NIL)
    (freplace (LINEDESCRIPTOR CR\END) of TOLINE with (ffetch (LINEDESCRIPTOR CR\END) of FROMLINE))
    (freplace (LINEDESCRIPTOR LDOBJ) of TOLINE with (ffetch (LINEDESCRIPTOR LDOBJ) of FROMLINE))
    (freplace (LINEDESCRIPTOR LHASPROT) of TOLINE with (ffetch (LINEDESCRIPTOR LHASPROT) of FROMLINE)
           )
    (freplace (LINEDESCRIPTOR LFMTSPEC) of TOLINE with (ffetch (LINEDESCRIPTOR LFMTSPEC) of FROMLINE)
           )
    (freplace (LINEDESCRIPTOR LTRUEDESCENT) of TOLINE with (ffetch (LINEDESCRIPTOR LTRUEDESCENT)
                                                              of FROMLINE))
    (freplace (LINEDESCRIPTOR LTRUEASCENT) of TOLINE with (ffetch (LINEDESCRIPTOR LTRUEASCENT)
                                                             of FROMLINE))
    (freplace (LINEDESCRIPTOR ASCENT) of TOLINE with (ffetch (LINEDESCRIPTOR ASCENT) of FROMLINE))
    (freplace (LINEDESCRIPTOR DESCENT) of TOLINE with (ffetch (LINEDESCRIPTOR DESCENT) of FROMLINE))
    (freplace (LINEDESCRIPTOR LHASTABS) of TOLINE with (ffetch (LINEDESCRIPTOR LHASTABS) of FROMLINE)
           )
    (freplace (LINEDESCRIPTOR LMARK) of TOLINE with (ffetch (LINEDESCRIPTOR LMARK) of FROMLINE))
    (freplace (LINEDESCRIPTOR 1STLN) of TOLINE with (ffetch (LINEDESCRIPTOR 1STLN) of FROMLINE))
    (freplace (LINEDESCRIPTOR LSTLN) of TOLINE with (ffetch (LINEDESCRIPTOR LSTLN) of FROMLINE])

(\TEDIT.FIXCHANGEDLINE
  [LAMBDA (TEXTOBJ PREVYBOT LINES WINDOW TEXTLEN THISLINE WHEIGHT CHARLIM NEXTCARETCH# PREVDESCENT)
                                                             (* ; "Edited 30-Jul-2022 21:15 by rmk")
                                                             (* ; "Edited 30-May-91 16:57 by jds")
                                                             (* ; 
                                      "Reformat a single line, if need be.  Returns the changed line")
    (PROG ((YBOT PREVYBOT)
           (FORMATDONE NIL)
           LIMITCHANGED WASDIRTY OCHLIM OLHEIGHT (PREVLINE NIL)
           (FOUND NIL)
           DY OFLOWFN NEWLINE)
          (CL:WHEN (IEQP CHARLIM 1)
              (SETQ CHARLIM (fetch (LINEDESCRIPTOR CHAR1) of LINES)))
          (CL:WHEN [OR (fetch (LINEDESCRIPTOR DIRTY) of LINES)
                       (NOT (IEQP CHARLIM (fetch (LINEDESCRIPTOR CHAR1) of LINES]

              (* ;; "Only act if this line has changed, or if there is a gap or overlap between this line and the prior one")

              (SETQ OCHLIM (fetch (LINEDESCRIPTOR CHARLIM) of LINES))
                                                             (* ; 
                                                    "This line's old CHLIM, for seeing if it changes")
              (SETQ OLHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES))
                                                             (* ; 
                                                  "This line's old height, for seeing if it changes.")
              (SETQ NEWLINE (\FORMATLINE TEXTOBJ NIL CHARLIM))
                                                             (* ; "Create the fresh line")
              (COND
                 ((AND (ILESSP CHARLIM (fetch (LINEDESCRIPTOR CHAR1) of LINES))
                       (IEQP (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of NEWLINE))
                             (fetch (LINEDESCRIPTOR CHAR1) of LINES)))
                                                             (* ; 
                                   "If this is a space-filling line, just move the other lines down.")
                  (\TEDIT.INSERTLINE NEWLINE LINES))
                 (T                                          (* ; 
                                                             "Otherwise, write over existing lines")
                    (\TEDIT.COPY.LINEDESCRIPTOR NEWLINE LINES)
                                                             (* ; "Move it into place in the chain")
                    (replace (THISLINE DESC) of THISLINE with LINES)
                                                             (* ; 
                     "And pretend that LINES is the line we just formatted--since it effectively IS.")
                    (SETQ NEWLINE LINES)                     (* ; 
                                                             "And copy it back over the original")
                    ))
              (SETQ CHARLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of NEWLINE)))

              (* ;; "Find the end of the new line (this MUST be before this COND, because LINES is set to NIL inside it.)")

              (COND
                 ((IGEQ (fetch (LINEDESCRIPTOR YBOT) of LINES)
                        WHEIGHT)                             (* ; 
                                     "Do nothing until we see a change to a line which is on-screen.")
                  (replace (LINEDESCRIPTOR YBOT) of NEWLINE with (fetch (LINEDESCRIPTOR YBOT)
                                                                    of LINES))
                                                             (* ; 
                               "Except to make sure that the fresh line also thinks it is off screen")
                  )
                 ((AND (IGEQ (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM YBOT NEWLINE (fetch (LINEDESCRIPTOR
                                                                                      PREVLINE)
                                                                                 of NEWLINE)))
                             (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                       (NEQ LINES NEWLINE))                  (* ; 
                          "If there's space left on the screen for this line, (and it is a new line)")
                  (\TEDIT.ADJUST.LINES TEXTOBJ (fetch (LINEDESCRIPTOR NEXTLINE) of NEWLINE)
                         WINDOW
                         (fetch (LINEDESCRIPTOR YBOT) of (fetch (LINEDESCRIPTOR PREVLINE)
                                                            of NEWLINE))
                         (IMINUS (fetch (LINEDESCRIPTOR LHEIGHT) of NEWLINE)))
                                                             (* ; 
                                                          "Move the existing lines down to fit it in")
                  (replace (LINEDESCRIPTOR YBOT) of NEWLINE with YBOT)
                                                             (* ; "Display it where we are now")
                  (replace (LINEDESCRIPTOR YBASE) of NEWLINE with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                      DESCENT)
                                                                                 of NEWLINE)))
                                                             (* ; 
                                                             "Base line for the characters to sit on")
                  (\DISPLAYLINE TEXTOBJ NEWLINE WINDOW)      (* ; "Display it")
                  )
                 ((IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
          "If there's space left on the screen for this line, and we're overlaying an existing line.")
                  [\TEDIT.ADJUST.LINES TEXTOBJ (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)
                         WINDOW
                         (IPLUS YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES)
                                (IMINUS OLHEIGHT))
                         (COND
                            ((fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR LFMTSPEC) of LINES))
                             (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of LINES)
                                    YBOT))
                            (T (IDIFFERENCE OLHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES]
                                                             (* ; 
                             "Adjust for the possible difference in heights between old and new line")
                  (replace (LINEDESCRIPTOR YBOT) of LINES with YBOT)
                                                             (* ; "Display it where we are now")
                  (replace (LINEDESCRIPTOR YBASE) of LINES with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                    DESCENT)
                                                                               of LINES)))
                                                             (* ; 
                                                             "Base line for the characters to sit on")
                  (\DISPLAYLINE TEXTOBJ LINES WINDOW)        (* ; "Display it")
                  )
                 ((AND NEXTCARETCH# (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINES)
                                          NEXTCARETCH#))     (* ; 
                        "This line is off-screen, but is needed for finding the caret's new location")
                  (replace (LINEDESCRIPTOR YBOT) of LINES with YBOT)
                  (replace (LINEDESCRIPTOR YBASE) of LINES with YBOT))
                 (T                                          (* ; 
                        "We have walked off the bottom of the screen.  Chop off the lines from here.")
                    (SETQ LINES NEWLINE)
                    (AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                         (APPLY* OFLOWFN WINDOW TEXTOBJ)
                         (RETFROM (FUNCTION \TEDIT.FIXCHANGEDLINE)))
                    [replace (LINEDESCRIPTOR YBOT) of LINES with (replace (LINEDESCRIPTOR YBASE)
                                                                    of LINES
                                                                    with (SUB1 (fetch (TEXTOBJ 
                                                                                             WBOTTOM)
                                                                                  of TEXTOBJ]
                                                             (* ; 
                                                             "Mark this line as being off-screen")
                    (COND
                       ((IGREATERP (fetch (LINEDESCRIPTOR CHARLIM) of LINES)
                               NEXTCARETCH#)
                        (replace (LINEDESCRIPTOR NEXTLINE) of LINES with NIL)))
                                                             (* ; 
   "Chop off any lines below it, to preserve changes that may propogate off the bottom of the window")
                    (\TEDIT.CLEAR.SCREEN.BELOW.LINE TEXTOBJ WINDOW (fetch (LINEDESCRIPTOR PREVLINE)
                                                                      of LINES))
                                                             (* ; 
                                            "And clear the space below the bottom line on the screen")
                    (RETURN)))
              (SETQ LINES NEWLINE)                           (* ; 
                      "So that if we inserted a line, we start by moving up to the pre-existing line")
              )
          (RETURN LINES])

(\TEDIT.FIXCHANGEDPART
  [LAMBDA (TEXTOBJ STARTINGLINE WINDOW INCREMENTAL? NEXTCARETCH#)
                                                             (* ; "Edited 30-May-91 16:07 by jds")

    (* ;; "Reformat lines as needed after a change.  Return the last line changed, or NIL if there's no need for a \FILLWINDOW.")

    (PROG* ((THISW (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ)))
            [LINES (fetch (LINEDESCRIPTOR NEXTLINE) of (WINDOWPROP THISW 'LINES]
            (REGION (DSPCLIPPINGREGION NIL THISW))
            (YBOT (fetch (REGION PTOP) of REGION))
            (FORMATDONE NIL)
            LIMITCHANGED WASDIRTY CHARLIM OCHLIM OLHEIGHT (PREVLINE NIL)
            (TPREVLINE NIL)
            (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
            (THISLINE (fetch (TEXTOBJ THISLINE) of TEXTOBJ))
            (WHEIGHT (fetch (REGION PTOP) of REGION))
            (WBOTTOM (fetch (REGION BOTTOM) of REGION))
            (CLEARBOTTOM T)
            [NEXTCARETCH# (OR NEXTCARETCH# (fetch (SELECTION CH#) of (fetch (TEXTOBJ SEL)
                                                                        of TEXTOBJ]
            DY OFLOWFN NEWLINE TYBOT)
           (AND LINES (SETQ TPREVLINE (fetch (LINEDESCRIPTOR PREVLINE) of LINES)))
           [while LINES do                                   (* ; 
                                                    "Find the first line descriptor of a DIRTY line.")
                           (SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of LINES))
                           (COND
                              ((ILESSP 0 (SETQ DY (IDIFFERENCE (\TEDIT.NEXT.LINE.BOTTOM
                                                                YBOT LINES (fetch (LINEDESCRIPTOR
                                                                                   PREVLINE)
                                                                              of LINES))
                                                         YBOT)))
                                                             (* ; 
                           "There used to be another line above this one.  Move this up to cover it.")
                               (\TEDIT.CLOSEUPLINES TEXTOBJ (fetch (LINEDESCRIPTOR PREVLINE)
                                                               of LINES)
                                      LINES NIL (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ)))
                                                             (* ; 
      "This HAS to fill the window, or we may wind up with missing lines at the bottom of the screen")
                               ))
                           (COND
                              ((AND (ILESSP YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                    (IGREATERP (fetch (LINEDESCRIPTOR CHAR1) of LINES)
                                           NEXTCARETCH#))    (* ; 
                                                            "We've run off the bottom of the screen.")
                               (replace (LINEDESCRIPTOR NEXTLINE) of TPREVLINE with NIL)
                                                             (* ; 
                                 "There may be unfixed changes there, so chop off any further lines.")
                               (SETQ LINES NIL))
                              ((fetch (LINEDESCRIPTOR DIRTY) of LINES)
                               (RETURN))
                              ([AND [NOT (IEQP (fetch (LINEDESCRIPTOR CHAR1) of LINES)
                                               (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of TPREVLINE]
                                    (NOT (ZEROP (fetch (LINEDESCRIPTOR CHARLIM) of TPREVLINE]

                               (* ;; "This line doesn't match up with the previous line;  we should start updating here.  But don't worry about the dummy first line")

                               (RETURN))
                              (T (SETQ TPREVLINE LINES)
                                 (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES]
           [COND
              ((AND LINES (ILESSP (fetch (LINEDESCRIPTOR CHARTOP) of LINES)
                                 0))                         (* ; 
                       "If we hit on the dummy first line, skip over it -- never try to reformat it.")
               (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES]
           [COND
              ((NOT LINES)                                   (* ; 
                                          "No changed lines found -- clear below last line on screen")
               (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                      (fetch (REGION WIDTH) of (DSPCLIPPINGREGION NIL WINDOW))
                      (IDIFFERENCE YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                      'TEXTURE
                      'REPLACE WHITESHADE)
               (COND
                  [[OR (ZEROP TEXTLEN)
                       (NOT (fetch (LINEDESCRIPTOR NEXTLINE) of (WINDOWPROP (OR WINDOW (
                                                                                      \TEDIT.PRIMARYW
                                                                                        TEXTOBJ))
                                                                       'LINES]

                   (* ;; "If there is no text, or no image, force a call to \FILLWINDOW, to provide a dummy empty line descriptor for the guy to type at.")

                   (RETURN (WINDOWPROP WINDOW 'LINES]
                  (T                                         (* ; 
                                               "We found no changes;  return a NIL last-line-changed")
                     (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
                                                             (* ; 
                        "Reset the 'needs-update' flag so we don't come back looking for work again.")
                     (RETURN NIL]
           [SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of (SETQ PREVLINE (fetch (LINEDESCRIPTOR PREVLINE)
                                                                        of LINES]
                                                             (* ; 
                                                            "Y bottom of the first line to reformat.")
           (SETQ CHARLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of PREVLINE)))
                                                             (* ; "char to start formatting with")
           (while (AND LINES (OR (IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                 (ILEQ CHARLIM NEXTCARETCH#)))
              do 
                 (* ;; "Run thru lines, cleaning them up.  Start with the first dirty line, and only stop if we're both past the place the caret will be AND off the bottom of the screen.")

                 [COND
                    ([ILESSP 0 (SETQ DY (IDIFFERENCE (\TEDIT.NEXT.LINE.BOTTOM YBOT LINES
                                                            (fetch (LINEDESCRIPTOR PREVLINE)
                                                               of LINES))
                                               (fetch (LINEDESCRIPTOR YBOT) of LINES]
                                                             (* ; 
                           "There used to be another line above this one.  Move this up to cover it.")
                     (\TEDIT.CLOSEUPLINES TEXTOBJ (fetch (LINEDESCRIPTOR PREVLINE) of LINES)
                            LINES NIL (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ]
                 [COND
                    ((IGREATERP CHARLIM (IMIN (IMAX 1 (fetch (LINEDESCRIPTOR CHARLIM) of LINES))
                                              TEXTLEN))      (* ; 
                                              "This line has been rendered superfluous -- Delete it.")
                     (TEDIT.DELETELINE LINES TEXTOBJ WINDOW))
                    (T 
                       (* ;; "Try updating the line.  If the updater returns NIL, it ran off the bottom of the screen, and we should give up.")

                       (COND
                          ((SETQ LINES (\TEDIT.FIXCHANGEDLINE TEXTOBJ YBOT LINES WINDOW TEXTLEN 
                                              THISLINE WHEIGHT CHARLIM NEXTCARETCH#
                                              (fetch (LINEDESCRIPTOR DESCENT) of PREVLINE)))
                                                             (* ; 
             "We're still on screen;  update the character and Y-position counters for the next loop")
                           (SETQ CHARLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of LINES)))
                           (SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of LINES)))
                          (T                                 (* ; 
    "Ran off the bottom of the window;  the bottom has already been cleared, so avoid doing it here.")
                             (SETQ CLEARBOTTOM NIL)
                             (RETURN]
                 (COND
                    ((IGEQ CHARLIM TEXTLEN)                  (* ; 
 "If we've run out of text, chop off any remaining line descriptors, since we won't be needing them.")
                     (replace (LINEDESCRIPTOR NEXTLINE) of LINES with NIL)
                     (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
                                                             (* ; 
                                                 "And there's no more screen updating to do, either.")
                     )
                    ((AND INCREMENTAL? (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)
                          (IGREATERP CHARLIM NEXTCARETCH#)
                          (\SYSBUFP))                        (* ; 
                  "This is an incremental update, and he hit a key.  Stop updating and listen to him")
                                                             (* ; 
                    "HOWEVER, NEVER STOP ON THE LAST LINE -- IF THERE ARE NEW LINES TO ADD, ADD ONE.")
                     (SETQ PREVLINE NIL)
                     (SETQ CLEARBOTTOM NIL)
                     (RETURN)))
                 (SETQ PREVLINE LINES)                       (* ; 
                                                        "Remember the last line we really formatted.")
                 (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)) 
                                                             (* ; "Move to the next line"))
           (COND
              (CLEARBOTTOM                                   (* ; 
     "There had been lines yet to be formatted, so there may be garbage below the end of the screen.")
                     (\TEDIT.CLEAR.SCREEN.BELOW.LINE TEXTOBJ WINDOW PREVLINE)))
           (RETURN PREVLINE])

(\TEDIT.INSERTLINE
  [LAMBDA (NEWLINE BEFORELINE)                               (* ; "Edited 30-May-91 16:05 by jds")
                                                             (* Inserts NEWLINE in front of 
                                                             BEFORELINE in the line-descriptor 
                                                             chain)
    (PROG ((PREVLINE (fetch (LINEDESCRIPTOR PREVLINE) of BEFORELINE)))
          (replace (LINEDESCRIPTOR PREVLINE) of NEWLINE with PREVLINE)
          (replace (LINEDESCRIPTOR NEXTLINE) of NEWLINE with BEFORELINE)
          (replace (LINEDESCRIPTOR PREVLINE) of BEFORELINE with NEWLINE)
          (AND PREVLINE (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with NEWLINE])

(\TEDIT.LINE.LIST
  [LAMBDA (TEXTOBJ WINDOW)                                  (* ; "Edited 12-Jun-90 19:23 by mitani")
    (for WW inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) as LINES inside (fetch (TEXTOBJ LINES)
                                                                           of TEXTOBJ)
       when (EQ WW WINDOW) do (RETURN LINES])

(\TEDIT.MARK.LINES.DIRTY
  [LAMBDA (TEXTOBJ CH1 CHLIM)                                (* ; "Edited 30-May-91 16:05 by jds")
                                                             (* Mark dirty the lines that intersect 
                                                             the range ch1 t chlim inclusive)
    (bind (CH# _ (IMIN CH1 (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
          (CHLIM# _ (COND
                       ((IEQP CHLIM -1)
                        (ADD1 (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
                       (T CHLIM))) for WW inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
       do (bind (LL _ (WINDOWPROP WW 'LINES)) while LL
             do                                              (* Mark changed lines as DIRTY.)
                (COND
                   ((AND (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LL)
                               CHLIM#)
                         (IGEQ (fetch (LINEDESCRIPTOR CHARTOP) of LL)
                               CH#))

         (* The dirty range overlaps with this line --
         it is between the 1st char on the line, and the last char examined when deciding 
         where to break the line.)

                    (replace (LINEDESCRIPTOR DIRTY) of LL with T)))
                (SETQ LL (fetch (LINEDESCRIPTOR NEXTLINE) of LL)))
       finally (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T])

(\TEDIT.NEXT.LINE.BOTTOM
  [LAMBDA (CURYBOT LINE PREVLINE)                            (* ; "Edited 24-Sep-87 10:00 by jds")

(* ;;; "Given a current Y-bottom for PREVLINE, and a LINE to follow it, compute the new line's YBOT value.  Takes into account Base-to-base leading, as well as paragraph leadings.")

    (PROG (NEWYBOT PARALEADING PARALOOKS BASETOBASE)
          [COND
             [[SETQ BASETOBASE (fetch (FMTSPEC FMTBASETOBASE) of (SETQ PARALOOKS (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                         LFMTSPEC)
                                                                                    of LINE]

              (* ;; "If base-to-base spacing is specified, we have to do this in two parts: First, compute the proper spacing between the lines;  then add in any paragraph leading.")

              [SETQ NEWYBOT (IDIFFERENCE (IPLUS CURYBOT (fetch (LINEDESCRIPTOR DESCENT) of PREVLINE))
                                   (IPLUS BASETOBASE (fetch (LINEDESCRIPTOR DESCENT) of LINE]
              (COND
                 ((fetch (LINEDESCRIPTOR 1STLN) of LINE)     (* ; 
                          "This is the first line of a new paragraph.  Add in any paragraph leading.")
                  [SETQ PARALEADING (IPLUS (fetch (FMTSPEC LEADBEFORE) of PARALOOKS)
                                           (fetch (FMTSPEC LEADAFTER) of (fetch (LINEDESCRIPTOR
                                                                                 LFMTSPEC)
                                                                            of PREVLINE]

                  (* ;; "The inter-paragraph space is the sum of the previous para's post-leading and this para's pre-leading.")

                  (SETQ NEWYBOT (IDIFFERENCE NEWYBOT PARALEADING]
             (T 
                (* ;; "If there's no base-to-base spacing, then paragraph leading was taken into account in the line formatter, and is already part of LHEIGHT.")

                (SETQ NEWYBOT (IDIFFERENCE CURYBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE]
          (RETURN NEWYBOT])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (12958 76685 (\FORMATLINE 12968 . 55914) (\FORMATLINE.NEWNSCHARS 55916 . 56947) (
\TEDIT.NSCHAR.RUN 56949 . 63631) (\TEDIT.PURGE.SPACES 63633 . 64027) (\DOFORMATTING 64029 . 76683)) (
76686 97811 (\DISPLAYLINE 76696 . 93718) (\TEDIT.LINECACHE 93720 . 94448) (\TEDIT.CREATE.LINECACHE 
94450 . 95286) (\TEDIT.BLTCHAR 95288 . 97809)) (98426 200698 (TEDIT.CR.UPDATESCREEN 98436 . 99655) (
TEDIT.DELETELINE 99657 . 100579) (TEDIT.INSERT.DISPLAYTEXT 100581 . 116725) (TEDIT.INSERT.UPDATESCREEN
 116727 . 122707) (TEDIT.UPDATE.SCREEN 122709 . 123809) (\BACKFORMAT 123811 . 127612) (\FILLWINDOW 
127614 . 141320) (\FIXDLINES 141322 . 147534) (\FIXILINES 147536 . 152657) (\SHOWTEXT 152659 . 155128)
 (\TEDIT.ADJUST.LINES 155130 . 162708) (\TEDIT.CLEAR.SCREEN.BELOW.LINE 162710 . 163448) (
\TEDIT.CLOSEUPLINES 163450 . 170917) (\TEDIT.COPY.LINEDESCRIPTOR 170919 . 174029) (
\TEDIT.FIXCHANGEDLINE 174031 . 184338) (\TEDIT.FIXCHANGEDPART 184340 . 195648) (\TEDIT.INSERTLINE 
195650 . 196478) (\TEDIT.LINE.LIST 196480 . 196878) (\TEDIT.MARK.LINES.DIRTY 196880 . 198397) (
\TEDIT.NEXT.LINE.BOTTOM 198399 . 200696)))))
STOP
